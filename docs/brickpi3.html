<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>brickpi3 API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>brickpi3</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># https://www.dexterindustries.com/BrickPi/
# https://github.com/DexterInd/BrickPi3
#
# Copyright (c) 2017 Dexter Industries
# Released under the MIT license (http://choosealicense.com/licenses/mit/).
# For more information see https://github.com/DexterInd/BrickPi3/blob/master/LICENSE.md
#
# Python drivers for the BrickPi3

from __future__ import print_function
from __future__ import division
#from builtins import input

import subprocess # for executing system calls
# import spidev
import array      # for converting hex string to byte array

FIRMWARE_VERSION_REQUIRED = &#34;1.4.x&#34; # Make sure the top 2 of 3 numbers match

# BP_SPI = spidev.SpiDev()
# BP_SPI.open(0, 1)
# BP_SPI.max_speed_hz = 500000
# BP_SPI.mode = 0b00
# BP_SPI.bits_per_word = 8


class Enumeration(object):
    def __init__(self, names):  # or *names, with no .split()
        number = 0
        for line, name in enumerate(names.split(&#39;\n&#39;)):
            if name.find(&#34;,&#34;) &gt;= 0:
                # strip out the spaces
                while(name.find(&#34; &#34;) != -1):
                    name = name[:name.find(&#34; &#34;)] + name[(name.find(&#34; &#34;) + 1):]

                # strip out the commas
                while(name.find(&#34;,&#34;) != -1):
                    name = name[:name.find(&#34;,&#34;)] + name[(name.find(&#34;,&#34;) + 1):]

                # if the value was specified
                if(name.find(&#34;=&#34;) != -1):
                    number = int(float(name[(name.find(&#34;=&#34;) + 1):]))
                    name = name[:name.find(&#34;=&#34;)]

                # optionally print to confirm that it&#39;s working correctly
                #print &#34;%40s has a value of %d&#34; % (name, number)

                setattr(self, name, number)
                number = number + 1


class FirmwareVersionError(Exception):
    &#34;&#34;&#34;Exception raised if the BrickPi3 firmware needs to be updated&#34;&#34;&#34;


class SensorError(Exception):
    &#34;&#34;&#34;Exception raised if a sensor is not yet configured when trying to read it with get_sensor&#34;&#34;&#34;


def set_address(address, id):
    &#34;&#34;&#34;
    Set the SPI address of the BrickPi3

    Keyword arguments:
    address -- the new SPI address to use (1 to 255)
    id -- the BrickPi3&#39;s unique serial number ID (so that the address can be set while multiple BrickPi3s are stacked on a Raspberry Pi).
    &#34;&#34;&#34;
    address = int(address)
    if address &lt; 1 or address &gt; 255:
        raise IOError(&#34;brickpi3.set_address error: SPI address must be in the range of 1 to 255&#34;)
        return

    if(len(id) != 32):
        if id == &#34;&#34;:
            id_arr = [0 for i in range(16)]
        else:
            raise IOError(&#34;brickpi3.set_address error: wrong serial number id length. Must be a 32-digit hex string.&#34;)
            return
    else:
        id_arr = array.array(&#39;B&#39;, bytearray.fromhex(id))
        if(len(id_arr) != 16):
            raise IOError(&#34;brickpi3.set_address error: unknown serial number id problem. Make sure to use a valid 32-digit hex string serial number.&#34;)
            return

    outArray = [0, BrickPi3.BPSPI_MESSAGE_TYPE.SET_ADDRESS, address]
    outArray.extend(id_arr)
    BP_SPI.xfer2(outArray)


class BrickPi3(object):
    PORT_1 = 0x01
    PORT_2 = 0x02
    PORT_3 = 0x04
    PORT_4 = 0x08

    PORT_A = 0x01
    PORT_B = 0x02
    PORT_C = 0x04
    PORT_D = 0x08

    MOTOR_FLOAT = -128

    SensorType = [0, 0, 0, 0]
    I2CInBytes = [0, 0, 0, 0]

    I2C_LENGTH_LIMIT = 16

    BPSPI_MESSAGE_TYPE = Enumeration(&#34;&#34;&#34;
        NONE,

        GET_MANUFACTURER,
        GET_NAME,
        GET_HARDWARE_VERSION,
        GET_FIRMWARE_VERSION,
        GET_ID,
        SET_LED,
        GET_VOLTAGE_3V3,
        GET_VOLTAGE_5V,
        GET_VOLTAGE_9V,
        GET_VOLTAGE_VCC,
        SET_ADDRESS,

        SET_SENSOR_TYPE,

        GET_SENSOR_1,
        GET_SENSOR_2,
        GET_SENSOR_3,
        GET_SENSOR_4,

        I2C_TRANSACT_1,
        I2C_TRANSACT_2,
        I2C_TRANSACT_3,
        I2C_TRANSACT_4,

        SET_MOTOR_POWER,

        SET_MOTOR_POSITION,

        SET_MOTOR_POSITION_KP,

        SET_MOTOR_POSITION_KD,

        SET_MOTOR_DPS,

        SET_MOTOR_DPS_KP,

        SET_MOTOR_DPS_KD,

        SET_MOTOR_LIMITS,

        OFFSET_MOTOR_ENCODER,

        GET_MOTOR_A_ENCODER,
        GET_MOTOR_B_ENCODER,
        GET_MOTOR_C_ENCODER,
        GET_MOTOR_D_ENCODER,

        GET_MOTOR_A_STATUS,
        GET_MOTOR_B_STATUS,
        GET_MOTOR_C_STATUS,
        GET_MOTOR_D_STATUS,
    &#34;&#34;&#34;)

    SENSOR_TYPE = Enumeration(&#34;&#34;&#34;
        NONE = 1,
        I2C,
        CUSTOM,

        TOUCH,
        NXT_TOUCH,
        EV3_TOUCH,

        NXT_LIGHT_ON,
        NXT_LIGHT_OFF,

        NXT_COLOR_RED,
        NXT_COLOR_GREEN,
        NXT_COLOR_BLUE,
        NXT_COLOR_FULL,
        NXT_COLOR_OFF,

        NXT_ULTRASONIC,

        EV3_GYRO_ABS,
        EV3_GYRO_DPS,
        EV3_GYRO_ABS_DPS,

        EV3_COLOR_REFLECTED,
        EV3_COLOR_AMBIENT,
        EV3_COLOR_COLOR,
        EV3_COLOR_RAW_REFLECTED,
        EV3_COLOR_COLOR_COMPONENTS,

        EV3_ULTRASONIC_CM,
        EV3_ULTRASONIC_INCHES,
        EV3_ULTRASONIC_LISTEN,

        EV3_INFRARED_PROXIMITY,
        EV3_INFRARED_SEEK,
        EV3_INFRARED_REMOTE,
    &#34;&#34;&#34;)

    SENSOR_STATE = Enumeration(&#34;&#34;&#34;
        VALID_DATA,
        NOT_CONFIGURED,
        CONFIGURING,
        NO_DATA,
        I2C_ERROR,
    &#34;&#34;&#34;)

    SENSOR_CUSTOM = Enumeration(&#34;&#34;&#34;
        PIN1_9V,
        PIN5_OUT,
        PIN5_STATE,
        PIN6_OUT,
        PIN6_STATE,
        PIN1_ADC,
        PIN6_ADC,
    &#34;&#34;&#34;)
    &#34;&#34;&#34;
    Flags for use with SENSOR_TYPE.CUSTOM

    PIN1_9V
        Enable 9V out on pin 1 (for LEGO NXT Ultrasonic sensor).

    PIN5_OUT
        Set pin 5 state to output. Pin 5 will be set to input if this flag is not set.

    PIN5_STATE
        If PIN5_OUT is set, this will set the state to output high, otherwise the state will
        be output low. If PIN5_OUT is not set, this flag has no effect.

    PIN6_OUT
        Set pin 6 state to output. Pin 6 will be set to input if this flag is not set.

    PIN6_STATE
        If PIN6_OUT is set, this will set the state to output high, otherwise the state will
        be output low. If PIN6_OUT is not set, this flag has no effect.

    PIN1_ADC
        Enable the analog/digital converter on pin 1 (e.g. for NXT analog sensors).

    PIN6_ADC
        Enable the analog/digital converter on pin 6.
    &#34;&#34;&#34;

    SENSOR_CUSTOM.PIN1_9V    = 0x0002
    SENSOR_CUSTOM.PIN5_OUT   = 0x0010
    SENSOR_CUSTOM.PIN5_STATE = 0x0020
    SENSOR_CUSTOM.PIN6_OUT   = 0x0100
    SENSOR_CUSTOM.PIN6_STATE = 0x0200
    SENSOR_CUSTOM.PIN1_ADC   = 0x1000
    SENSOR_CUSTOM.PIN6_ADC   = 0x4000

    SENSOR_I2C_SETTINGS = Enumeration(&#34;&#34;&#34;
        MID_CLOCK,
        PIN1_9V,
        SAME,
        ALLOW_STRETCH_ACK,
        ALLOW_STRETCH_ANY,
    &#34;&#34;&#34;)

    SENSOR_I2C_SETTINGS.MID_CLOCK         = 0x01 # Send the clock pulse between reading and writing. Required by the NXT US sensor.
    SENSOR_I2C_SETTINGS.PIN1_9V           = 0x02 # 9v pullup on pin 1
    SENSOR_I2C_SETTINGS.SAME              = 0x04 # Keep performing the same transaction e.g. keep polling a sensor

    MOTOR_STATUS_FLAG = Enumeration(&#34;&#34;&#34;
        LOW_VOLTAGE_FLOAT,
        OVERLOADED,
    &#34;&#34;&#34;)

    MOTOR_STATUS_FLAG.LOW_VOLTAGE_FLOAT = 0x01 # If the motors are floating due to low battery voltage
    MOTOR_STATUS_FLAG.OVERLOADED        = 0x02 # If the motors aren&#39;t close to the target (applies to position control and dps speed control).

    #SUCCESS = 0
    #SPI_ERROR = 1
    #SENSOR_ERROR = 2
    #SENSOR_TYPE_ERROR = 3

    def __init__(self, addr = 1, detect = True): # Configure for the BrickPi. Optionally set the address (default to 1). Optionally disable detection (default to detect).
        &#34;&#34;&#34;
        Do any necessary configuration, and optionally detect the BrickPi3

        Optionally specify the SPI address as something other than 1
        Optionally disable the detection of the BrickPi3 hardware. This can be used for debugging and testing when the BrickPi3 would otherwise not pass the detection tests.
        &#34;&#34;&#34;

        if addr &lt; 1 or addr &gt; 255:
            raise IOError(&#34;error: SPI address must be in the range of 1 to 255&#34;)
            return

        self.SPI_Address = addr
        if detect == True:
            try:
                manufacturer = self.get_manufacturer()
                board = self.get_board()
                vfw = self.get_version_firmware()
            except IOError():
                raise IOError(&#34;No SPI response&#34;)
            if manufacturer != &#34;Dexter Industries&#34; or board != &#34;BrickPi3&#34;:
                raise IOError(&#34;No SPI response&#34;)
            if vfw.split(&#39;.&#39;)[0] != FIRMWARE_VERSION_REQUIRED.split(&#39;.&#39;)[0] or vfw.split(&#39;.&#39;)[1] != FIRMWARE_VERSION_REQUIRED.split(&#39;.&#39;)[1]:
                raise FirmwareVersionError(&#34;BrickPi3 firmware needs to be version %s but is currently version %s&#34; % (FIRMWARE_VERSION_REQUIRED, vfw))

    def spi_transfer_array(self, data_out):
        &#34;&#34;&#34;
        Conduct a SPI transaction

        Keyword arguments:
        data_out -- a list of bytes to send. The length of the list will determine how many bytes are transferred.

        Returns a list of the bytes read.
        &#34;&#34;&#34;
        return BP_SPI.xfer2(data_out)

    def spi_write_8(self, MessageType, Value):
        &#34;&#34;&#34;
        Send an 8-bit value over SPI

        Keyword arguments:
        MessageType -- the SPI message type
        Value -- the value to be sent
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, MessageType, (Value &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def spi_read_16(self, MessageType):
        &#34;&#34;&#34;
        Read a 16-bit value over SPI

        Keyword arguments:
        MessageType -- the SPI message type

        Returns:
        value
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, MessageType, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            return int((reply[4] &lt;&lt; 8) | reply[5])
        raise IOError(&#34;No SPI response&#34;)
        return

    def spi_write_16(self, MessageType, Value):
        &#34;&#34;&#34;
        Send a 16-bit value over SPI

        Keyword arguments:
        MessageType -- the SPI message type
        Value -- the value to be sent
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, MessageType, ((Value &gt;&gt; 8) &amp; 0xFF), (Value &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def spi_write_24(self, MessageType, Value):
        &#34;&#34;&#34;
        Send a 24-bit value over SPI

        Keyword arguments:
        MessageType -- the SPI message type
        Value -- the value to be sent
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, MessageType, ((Value &gt;&gt; 16) &amp; 0xFF), ((Value &gt;&gt; 8) &amp; 0xFF), (Value &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def spi_read_32(self, MessageType):
        &#34;&#34;&#34;
        Read a 32-bit value over SPI

        Keyword arguments:
        MessageType -- the SPI message type

        Returns :
        value
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, MessageType, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            return int((reply[4] &lt;&lt; 24) | (reply[5] &lt;&lt; 16) | (reply[6] &lt;&lt; 8) | reply[7])
        raise IOError(&#34;No SPI response&#34;)
        return

    def spi_write_32(self, MessageType, Value):
        &#34;&#34;&#34;
        Send a 32-bit value over SPI

        Keyword arguments:
        MessageType -- the SPI message type
        Value -- the value to be sent
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, MessageType, ((Value &gt;&gt; 24) &amp; 0xFF), ((Value &gt;&gt; 16) &amp; 0xFF), ((Value &gt;&gt; 8) &amp; 0xFF), (Value &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def get_manufacturer(self):
        &#34;&#34;&#34;
        Read the 20 charactor BrickPi3 manufacturer name

        Returns:
        BrickPi3 manufacturer name string
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.GET_MANUFACTURER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            name = &#34;&#34;
            for c in range(4, 24):
                if reply[c] != 0:
                    name += chr(reply[c])
                else:
                    break
            return name
        raise IOError(&#34;No SPI response&#34;)
        return

    def get_board(self):
        &#34;&#34;&#34;
        Read the 20 charactor BrickPi3 board name

        Returns:
        BrickPi3 board name string
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.GET_NAME, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            name = &#34;&#34;
            for c in range(4, 24):
                if reply[c] != 0:
                    name += chr(reply[c])
                else:
                    break
            return name
        raise IOError(&#34;No SPI response&#34;)
        return

    def get_version_hardware(self):
        &#34;&#34;&#34;
        Read the hardware version

        Returns:
        hardware version
        &#34;&#34;&#34;
        version = self.spi_read_32(self.BPSPI_MESSAGE_TYPE.GET_HARDWARE_VERSION)
        return (&#34;%d.%d.%d&#34; % ((version / 1000000), ((version / 1000) % 1000), (version % 1000)))

    def get_version_firmware(self):
        &#34;&#34;&#34;
        Read the firmware version

        Returns:
        firmware version
        &#34;&#34;&#34;
        version = self.spi_read_32(self.BPSPI_MESSAGE_TYPE.GET_FIRMWARE_VERSION)
        return (&#34;%d.%d.%d&#34; % ((version / 1000000), ((version / 1000) % 1000), (version % 1000)))

    def get_id(self):
        &#34;&#34;&#34;
        Read the 128-bit BrickPi hardware serial number

        Returns:
        serial number as 32 char HEX formatted string
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.GET_ID, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            return (&#34;%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X&#34; % (reply[4], reply[5], reply[6], reply[7], reply[8], reply[9], reply[10], reply[11], reply[12], reply[13], reply[14], reply[15], reply[16], reply[17], reply[18], reply[19]))
        raise IOError(&#34;No SPI response&#34;)
        return

    def set_led(self, value):
        &#34;&#34;&#34;
        Control the onboard LED

        Keyword arguments:
        value -- the value (in percent) to set the LED brightness to. -1 returns control of the LED to the firmware.
        &#34;&#34;&#34;
        self.spi_write_8(self.BPSPI_MESSAGE_TYPE.SET_LED, value)

    def get_voltage_3v3(self):
        &#34;&#34;&#34;
        Get the 3.3v circuit voltage

        Returns:
        3.3v circuit voltage
        &#34;&#34;&#34;
        value = self.spi_read_16(self.BPSPI_MESSAGE_TYPE.GET_VOLTAGE_3V3)
        return (value / 1000.0)

    def get_voltage_5v(self):
        &#34;&#34;&#34;
        Get the 5v circuit voltage

        Returns:
        5v circuit voltage
        &#34;&#34;&#34;
        value = self.spi_read_16(self.BPSPI_MESSAGE_TYPE.GET_VOLTAGE_5V)
        return (value / 1000.0)

    def get_voltage_9v(self):
        &#34;&#34;&#34;
        Get the 9v circuit voltage

        Returns:
        9v circuit voltage
        &#34;&#34;&#34;
        value = self.spi_read_16(self.BPSPI_MESSAGE_TYPE.GET_VOLTAGE_9V)
        return (value / 1000.0)

    def get_voltage_battery(self):
        &#34;&#34;&#34;
        Get the battery voltage

        Returns:
        battery voltage
        &#34;&#34;&#34;
        value = self.spi_read_16(self.BPSPI_MESSAGE_TYPE.GET_VOLTAGE_VCC)
        return (value / 1000.0)

    def set_sensor_type(self, port, type, params = 0):
        &#34;&#34;&#34;
        Set the sensor type

        Keyword arguments:
        port -- The sensor port(s). PORT_1, PORT_2, PORT_3, and/or PORT_4.
        type -- The sensor type
        params = 0 -- the parameters needed for some sensor types.

        params is used for the following sensor types:
            CUSTOM -- a 16-bit integer used to configure the hardware.
            I2C -- a list of settings:
                params[0] -- Settings/flags
                params[1] -- target Speed in microseconds (0-255). Realistically the speed will vary.
                if SENSOR_I2C_SETTINGS_SAME flag set in I2C Settings:
                    params[2] -- Delay in microseconds between transactions.
                    params[3] -- Address
                    params[4] -- List of bytes to write
                    params[5] -- Number of bytes to read
        &#34;&#34;&#34;
        for p in range(4):
            if port &amp; (1 &lt;&lt; p):
                self.SensorType[p] = type
        if(type == self.SENSOR_TYPE.CUSTOM):
            outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_SENSOR_TYPE, int(port), type, ((params[0] &gt;&gt; 8) &amp; 0xFF), (params[0] &amp; 0xFF)]

            #self.spi_write_24(self.BPSPI_MESSAGE_TYPE.SET_SENSOR_TYPE, int(port), ((type &lt;&lt; 16) + (params[0])))
        elif(type == self.SENSOR_TYPE.I2C):
            if len(params) &gt;= 2:
                outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_SENSOR_TYPE, int(port), type, params[0], params[1]] # Settings, SpeedUS
                if params[0] &amp; self.SENSOR_I2C_SETTINGS.SAME and len(params) &gt;= 6:
                    outArray.append((params[2] &gt;&gt; 24) &amp; 0xFF) # DelayUS
                    outArray.append((params[2] &gt;&gt; 16) &amp; 0xFF) #   &#39;&#39;
                    outArray.append((params[2] &gt;&gt; 8) &amp; 0xFF)  #   &#39;&#39;
                    outArray.append(params[2] &amp; 0xFF)         #   &#39;&#39;
                    outArray.append(params[3] &amp; 0xFF)   # Address
                    outArray.append(params[5] &amp; 0xFF)   # InBytes
                    for p in range(4):
                        if port &amp; (1 &lt;&lt; p):
                            self.I2CInBytes[p] = params[5] &amp; 0xFF
                    outArray.append(len(params[4]))     # OutBytes
                    outArray.extend(params[4])          # OutArray
        else:
            outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_SENSOR_TYPE, int(port), type]

        self.spi_transfer_array(outArray)

    def transact_i2c(self, port, Address, OutArray, InBytes):
        &#34;&#34;&#34;
        Conduct an I2C transaction

        Keyword arguments:
        port -- The sensor port (one at a time). PORT_1, PORT_2, PORT_3, or PORT_4.
        Address -- The I2C address for the device. Bits 1-7, not 0-6.
        OutArray -- A list of bytes to write to the device
        InBytes -- The number of bytes to read from the device
        &#34;&#34;&#34;
        if port == self.PORT_1:
            message_type = self.BPSPI_MESSAGE_TYPE.I2C_TRANSACT_1
            port_index = 0
        elif port == self.PORT_2:
            message_type = self.BPSPI_MESSAGE_TYPE.I2C_TRANSACT_2
            port_index = 1
        elif port == self.PORT_3:
            message_type = self.BPSPI_MESSAGE_TYPE.I2C_TRANSACT_3
            port_index = 2
        elif port == self.PORT_4:
            message_type = self.BPSPI_MESSAGE_TYPE.I2C_TRANSACT_4
            port_index = 3
        else:
            raise IOError(&#34;transact_i2c error. Must be one sensor port at a time. PORT_1, PORT_2, PORT_3, or PORT_4.&#34;)
            return

        if self.SensorType[port_index] != self.SENSOR_TYPE.I2C:
            return
        outArray = [self.SPI_Address, message_type, Address, InBytes]
        self.I2CInBytes[port_index] = InBytes
        OutBytes = len(OutArray)
        if(OutBytes &gt; self.I2C_LENGTH_LIMIT):
            outArray.append(self.I2C_LENGTH_LIMIT)
            for b in range(self.I2C_LENGTH_LIMIT):
                outArray.append(OutArray[b])
        else:
            outArray.append(OutBytes)
            outArray.extend(OutArray)
        self.spi_transfer_array(outArray)

    def get_sensor(self, port):
        &#34;&#34;&#34;
        Read a sensor value

        Keyword arguments:
        port -- The sensor port (one at a time). PORT_1, PORT_2, PORT_3, or PORT_4.

        Returns the value(s) for the specified sensor.
            The following sensor types each return a single value:
                NONE ----------------------- 0
                TOUCH ---------------------- 0 or 1 (released or pressed)
                NXT_TOUCH ------------------ 0 or 1 (released or pressed)
                EV3_TOUCH ------------------ 0 or 1 (released or pressed)
                NXT_ULTRASONIC ------------- distance in CM
                NXT_LIGHT_ON  -------------- reflected light
                NXT_LIGHT_OFF -------------- ambient light
                NXT_COLOR_RED -------------- red reflected light
                NXT_COLOR_GREEN ------------ green reflected light
                NXT_COLOR_BLUE ------------- blue reflected light
                NXT_COLOR_OFF -------------- ambient light
                EV3_GYRO_ABS --------------- absolute rotation position in degrees
                EV3_GYRO_DPS --------------- rotation rate in degrees per second
                EV3_COLOR_REFLECTED -------- red reflected light
                EV3_COLOR_AMBIENT ---------- ambient light
                EV3_COLOR_COLOR ------------ detected color
                EV3_ULTRASONIC_CM ---------- distance in CM
                EV3_ULTRASONIC_INCHES ------ distance in inches
                EV3_ULTRASONIC_LISTEN ------ 0 or 1 (no other ultrasonic sensors or another ultrasonic sensor detected)
                EV3_INFRARED_PROXIMITY ----- distance 0-100%

            The following sensor types each return a list of values
                CUSTOM --------------------- Pin 1 ADC (5v scale from 0 to 4095), Pin 6 ADC (3.3v scale from 0 to 4095), Pin 5 digital, Pin 6 digital
                I2C ------------------------ the I2C bytes read
                NXT_COLOR_FULL ------------- detected color, red light reflected, green light reflected, blue light reflected, ambient light
                EV3_GYRO_ABS_DPS ----------- absolute rotation position in degrees, rotation rate in degrees per second
                EV3_COLOR_RAW_REFLECTED ---- red reflected light, unknown value (maybe a raw ambient value?)
                EV3_COLOR_COLOR_COMPONENTS - red reflected light, green reflected light, blue reflected light, unknown value (maybe a raw value?)
                EV3_INFRARED_SEEK ---------- a list for each of the four channels. For each channel heading (-25 to 25), distance (-128 or 0 to 100)
                EV3_INFRARED_REMOTE -------- a list for each of the four channels. For each channel red up, red down, blue up, blue down, boadcast

        &#34;&#34;&#34;
        if port == self.PORT_1:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_1
            port_index = 0
        elif port == self.PORT_2:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_2
            port_index = 1
        elif port == self.PORT_3:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_3
            port_index = 2
        elif port == self.PORT_4:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_4
            port_index = 3
        else:
            raise IOError(&#34;get_sensor error. Must be one sensor port at a time. PORT_1, PORT_2, PORT_3, or PORT_4.&#34;)
            return

        if self.SensorType[port_index] == self.SENSOR_TYPE.CUSTOM:
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    return [(((reply[8] &amp; 0x0F) &lt;&lt; 8) | reply[9]), (((reply[8] &gt;&gt; 4) &amp; 0x0F) | (reply[7] &lt;&lt; 4)), (reply[6] &amp; 0x01), ((reply[6] &gt;&gt; 1) &amp; 0x01)]
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif self.SensorType[port_index] == self.SENSOR_TYPE.I2C:
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0]
            for b in range(self.I2CInBytes[port_index]):
                outArray.append(0)
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA and len(reply) - 6 == self.I2CInBytes[port_index]):
                    values = []
                    for b in range(6, len(reply)):
                        values.append(reply[b])
                    return values
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif(self.SensorType[port_index] == self.SENSOR_TYPE.TOUCH
          or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_TOUCH
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_TOUCH
          or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_ULTRASONIC
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_REFLECTED
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_AMBIENT
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_COLOR
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_LISTEN
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_INFRARED_PROXIMITY):
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if((reply[4] == self.SensorType[port_index] or (self.SensorType[port_index] == self.SENSOR_TYPE.TOUCH and (reply[4] == self.SENSOR_TYPE.NXT_TOUCH or reply[4] == self.SENSOR_TYPE.EV3_TOUCH))) and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    return reply[6]
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_FULL:
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    return [reply[6], ((reply[7] &lt;&lt; 2) | ((reply[11] &gt;&gt; 6) &amp; 0x03)), ((reply[8] &lt;&lt; 2) | ((reply[11] &gt;&gt; 4) &amp; 0x03)), ((reply[9] &lt;&lt; 2) | ((reply[11] &gt;&gt; 2) &amp; 0x03)), ((reply[10] &lt;&lt; 2) | (reply[11] &amp; 0x03))]
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif(self.SensorType[port_index] == self.SENSOR_TYPE.NXT_LIGHT_ON
          or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_LIGHT_OFF
          or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_RED
          or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_GREEN
          or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_BLUE
          or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_OFF
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_ABS
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_DPS
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_CM
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_INCHES):
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    value = int((reply[6] &lt;&lt; 8) | reply[7])
                    if((self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_ABS
                    or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_DPS)
                    and (value &amp; 0x8000)):
                        value = value - 0x10000
                    elif(self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_CM
                      or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_INCHES):
                        value = value / 10
                    return value
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif(self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_RAW_REFLECTED
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_ABS_DPS):
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    results = [int((reply[6] &lt;&lt; 8) | reply[7]), int((reply[8] &lt;&lt; 8) | reply[9])]
                    if self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_ABS_DPS:
                        for r in range(len(results)):
                            if results[r] &gt;= 0x8000:
                                results[r] = results[r] - 0x10000
                    return results
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif(self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_COLOR_COMPONENTS):
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    return [int((reply[6] &lt;&lt; 8) | reply[7]), int((reply[8] &lt;&lt; 8) | reply[9]), int((reply[10] &lt;&lt; 8) | reply[11]), int((reply[12] &lt;&lt; 8) | reply[13])]
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif(self.SensorType[port_index] == self.SENSOR_TYPE.EV3_INFRARED_SEEK):
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    results = [[int(reply[6]), int(reply[7])], [int(reply[8]), int(reply[9])], [int(reply[10]), int(reply[11])], [int(reply[12]), int(reply[13])]]
                    for c in range(len(results)):
                        for v in range(len(results[c])):
                            if results[c][v] &gt;= 0x80:
                                results[c][v] = results[c][v] - 0x100
                    return results
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif(self.SensorType[port_index] == self.SENSOR_TYPE.EV3_INFRARED_REMOTE):
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    results = [0, 0, 0, 0]
                    for r in range(len(results)):
                        value = int(reply[6 + r])
                        if value == 1:
                            results[r] = [1, 0, 0, 0, 0]
                        elif value == 2:
                            results[r] = [0, 1, 0, 0, 0]
                        elif value == 3:
                            results[r] = [0, 0, 1, 0, 0]
                        elif value == 4:
                            results[r] = [0, 0, 0, 1, 0]
                        elif value == 5:
                            results[r] = [1, 0, 1, 0, 0]
                        elif value == 6:
                            results[r] = [1, 0, 0, 1, 0]
                        elif value == 7:
                            results[r] = [0, 1, 1, 0, 0]
                        elif value == 8:
                            results[r] = [0, 1, 0, 1, 0]
                        elif value == 9:
                            results[r] = [0, 0, 0, 0, 1]
                        elif value == 10:
                            results[r] = [1, 1, 0, 0, 0]
                        elif value == 11:
                            results[r] = [0, 0, 1, 1, 0]
                        else:
                            results[r] = [0, 0, 0, 0, 0]
                    return results
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        raise IOError(&#34;get_sensor error: Sensor not configured or not supported.&#34;)
        return # sensor not configured or not supported.

    def set_motor_power(self, port, power):
        &#34;&#34;&#34;
        Set the motor power in percent

        Keyword arguments:
        port -- The Motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        power -- The power from -100 to 100, or -128 for float
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_POWER, int(port), int(power)]
        self.spi_transfer_array(outArray)

    def set_motor_position(self, port, position):
        &#34;&#34;&#34;
        Set the motor target position in degrees

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        position -- The target position
        &#34;&#34;&#34;
        position = int(position)
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_POSITION, int(port), ((position &gt;&gt; 24) &amp; 0xFF), ((position &gt;&gt; 16) &amp; 0xFF), ((position &gt;&gt; 8) &amp; 0xFF), (position &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def set_motor_position_relative(self, port, degrees):
        &#34;&#34;&#34;
        Set the relative motor target position in degrees. Current position plus the specified degrees.

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        degrees -- The relative target position in degrees
        &#34;&#34;&#34;
        for p in range(4):
            if port &amp; (1 &lt;&lt; p):
                self.set_motor_position((1 &lt;&lt; p), (self.get_motor_encoder(1 &lt;&lt; p) + degrees))

    def set_motor_position_kp(self, port, kp = 25):
        &#34;&#34;&#34;
        Set the motor target position KP constant

        If you set kp higher, the motor will be more responsive to errors in position, at the cost of perhaps overshooting and oscillating.
        kd slows down the motor as it approaches the target, and helps to prevent overshoot.
        In general, if you increase kp, you should also increase kd to keep the motor from overshooting and oscillating.

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        kp -- The KP constant (default 25)
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_POSITION_KP, int(port), int(kp)]
        self.spi_transfer_array(outArray)

    def set_motor_position_kd(self, port, kd = 70):
        &#34;&#34;&#34;
        Set the motor target position KD constant

        If you set kp higher, the motor will be more responsive to errors in position, at the cost of perhaps overshooting and oscillating.
        kd slows down the motor as it approaches the target, and helps to prevent overshoot.
        In general, if you increase kp, you should also increase kd to keep the motor from overshooting and oscillating.

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        kd -- The KD constant (default 70)
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_POSITION_KD, int(port), int(kd)]
        self.spi_transfer_array(outArray)

    def set_motor_dps(self, port, dps):
        &#34;&#34;&#34;
        Set the motor target speed in degrees per second

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        dps -- The target speed in degrees per second
        &#34;&#34;&#34;
        dps = int(dps)
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_DPS, int(port), ((dps &gt;&gt; 8) &amp; 0xFF), (dps &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def set_motor_limits(self, port, power = 0, dps = 0):
        &#34;&#34;&#34;
        Set the motor speed limit

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        power -- The power limit in percent (0 to 100), with 0 being no limit (100)
        dps -- The speed limit in degrees per second, with 0 being no limit
        &#34;&#34;&#34;
        dps = int(dps)
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_LIMITS, int(port), int(power), ((dps &gt;&gt; 8) &amp; 0xFF), (dps &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def get_motor_status(self, port):
        &#34;&#34;&#34;
        Read a motor status

        Keyword arguments:
        port -- The motor port (one at a time). PORT_A, PORT_B, PORT_C, or PORT_D.

        Returns a list:
            flags -- 8-bits of bit-flags that indicate motor status:
                bit 0 -- LOW_VOLTAGE_FLOAT - The motors are automatically disabled because the battery voltage is too low
                bit 1 -- OVERLOADED - The motors aren&#39;t close to the target (applies to position control and dps speed control).
            power -- the raw PWM power in percent (-100 to 100)
            encoder -- The encoder position
            dps -- The current speed in Degrees Per Second
        &#34;&#34;&#34;
        if port == self.PORT_A:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_A_STATUS
        elif port == self.PORT_B:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_B_STATUS
        elif port == self.PORT_C:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_C_STATUS
        elif port == self.PORT_D:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_D_STATUS
        else:
            raise IOError(&#34;get_motor_status error. Must be one motor port at a time. PORT_A, PORT_B, PORT_C, or PORT_D.&#34;)
            return

        outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            speed = int(reply[5])
            if speed &amp; 0x80:
                speed = speed - 0x100

            encoder = int((reply[6] &lt;&lt; 24) | (reply[7] &lt;&lt; 16) | (reply[8] &lt;&lt; 8) | reply[9])
            if encoder &amp; 0x80000000: # MT was 0x10000000, but I think it should be 0x80000000
                encoder = int(encoder - 0x100000000)

            dps = int((reply[10] &lt;&lt; 8) | reply[11])
            if dps &amp; 0x8000:
                dps = dps - 0x10000

            return [reply[4], speed, encoder, dps]
        raise IOError(&#34;No SPI response&#34;)
        return

    def get_motor_encoder(self, port):
        &#34;&#34;&#34;
        Read a motor encoder in degrees

        Keyword arguments:
        port -- The motor port (one at a time). PORT_A, PORT_B, PORT_C, or PORT_D.

        Returns the encoder position in degrees
        &#34;&#34;&#34;
        if port == self.PORT_A:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_A_ENCODER
        elif port == self.PORT_B:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_B_ENCODER
        elif port == self.PORT_C:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_C_ENCODER
        elif port == self.PORT_D:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_D_ENCODER
        else:
            raise IOError(&#34;get_motor_encoder error. Must be one motor port at a time. PORT_A, PORT_B, PORT_C, or PORT_D.&#34;)
            return

        encoder = self.spi_read_32(message_type)
        if encoder &amp; 0x80000000:
            encoder = int(encoder - 0x100000000)
        return int(encoder)

    def offset_motor_encoder(self, port, position):
        &#34;&#34;&#34;
        Offset a motor encoder

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        offset -- The encoder offset

        You can zero the encoder by offsetting it by the current position
        &#34;&#34;&#34;
        position = int(position)
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.OFFSET_MOTOR_ENCODER, int(port), ((position &gt;&gt; 24) &amp; 0xFF), ((position &gt;&gt; 16) &amp; 0xFF), ((position &gt;&gt; 8) &amp; 0xFF), (position &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def reset_motor_encoder(self, port):
        &#34;&#34;&#34;
        Reset motor encoder(s) to 0

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        &#34;&#34;&#34;
        if port &amp; self.PORT_A:
            self.offset_motor_encoder(self.PORT_A, self.get_motor_encoder(self.PORT_A))

        if port &amp; self.PORT_B:
            self.offset_motor_encoder(self.PORT_B, self.get_motor_encoder(self.PORT_B))

        if port &amp; self.PORT_C:
            self.offset_motor_encoder(self.PORT_C, self.get_motor_encoder(self.PORT_C))

        if port &amp; self.PORT_D:
            self.offset_motor_encoder(self.PORT_D, self.get_motor_encoder(self.PORT_D))

    def reset_all(self):
        &#34;&#34;&#34;
        Reset the BrickPi. Set all the sensors&#39; type to NONE, set the motors to float, and motors&#39; limits and constants to default, and return control of the LED to the firmware.
        &#34;&#34;&#34;
        # reset all sensors
        self.set_sensor_type(self.PORT_1 + self.PORT_2 + self.PORT_3 + self.PORT_4, self.SENSOR_TYPE.NONE)

        # turn off all motors
        self.set_motor_power(self.PORT_A + self.PORT_B + self.PORT_C + self.PORT_D, self.MOTOR_FLOAT)

        # reset motor limits
        self.set_motor_limits(self.PORT_A + self.PORT_B + self.PORT_C + self.PORT_D)

        # reset motor kP and kD constants
        self.set_motor_position_kp(self.PORT_A + self.PORT_B + self.PORT_C + self.PORT_D)
        self.set_motor_position_kd(self.PORT_A + self.PORT_B + self.PORT_C + self.PORT_D)

        # return the LED to the control of the FW
        self.set_led(-1)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="brickpi3.set_address"><code class="name flex">
<span>def <span class="ident">set_address</span></span>(<span>address, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the SPI address of the BrickPi3</p>
<p>Keyword arguments:
address &ndash; the new SPI address to use (1 to 255)
id &ndash; the BrickPi3's unique serial number ID (so that the address can be set while multiple BrickPi3s are stacked on a Raspberry Pi).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_address(address, id):
    &#34;&#34;&#34;
    Set the SPI address of the BrickPi3

    Keyword arguments:
    address -- the new SPI address to use (1 to 255)
    id -- the BrickPi3&#39;s unique serial number ID (so that the address can be set while multiple BrickPi3s are stacked on a Raspberry Pi).
    &#34;&#34;&#34;
    address = int(address)
    if address &lt; 1 or address &gt; 255:
        raise IOError(&#34;brickpi3.set_address error: SPI address must be in the range of 1 to 255&#34;)
        return

    if(len(id) != 32):
        if id == &#34;&#34;:
            id_arr = [0 for i in range(16)]
        else:
            raise IOError(&#34;brickpi3.set_address error: wrong serial number id length. Must be a 32-digit hex string.&#34;)
            return
    else:
        id_arr = array.array(&#39;B&#39;, bytearray.fromhex(id))
        if(len(id_arr) != 16):
            raise IOError(&#34;brickpi3.set_address error: unknown serial number id problem. Make sure to use a valid 32-digit hex string serial number.&#34;)
            return

    outArray = [0, BrickPi3.BPSPI_MESSAGE_TYPE.SET_ADDRESS, address]
    outArray.extend(id_arr)
    BP_SPI.xfer2(outArray)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="brickpi3.BrickPi3"><code class="flex name class">
<span>class <span class="ident">BrickPi3</span></span>
<span>(</span><span>addr=1, detect=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Do any necessary configuration, and optionally detect the BrickPi3</p>
<p>Optionally specify the SPI address as something other than 1
Optionally disable the detection of the BrickPi3 hardware. This can be used for debugging and testing when the BrickPi3 would otherwise not pass the detection tests.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BrickPi3(object):
    PORT_1 = 0x01
    PORT_2 = 0x02
    PORT_3 = 0x04
    PORT_4 = 0x08

    PORT_A = 0x01
    PORT_B = 0x02
    PORT_C = 0x04
    PORT_D = 0x08

    MOTOR_FLOAT = -128

    SensorType = [0, 0, 0, 0]
    I2CInBytes = [0, 0, 0, 0]

    I2C_LENGTH_LIMIT = 16

    BPSPI_MESSAGE_TYPE = Enumeration(&#34;&#34;&#34;
        NONE,

        GET_MANUFACTURER,
        GET_NAME,
        GET_HARDWARE_VERSION,
        GET_FIRMWARE_VERSION,
        GET_ID,
        SET_LED,
        GET_VOLTAGE_3V3,
        GET_VOLTAGE_5V,
        GET_VOLTAGE_9V,
        GET_VOLTAGE_VCC,
        SET_ADDRESS,

        SET_SENSOR_TYPE,

        GET_SENSOR_1,
        GET_SENSOR_2,
        GET_SENSOR_3,
        GET_SENSOR_4,

        I2C_TRANSACT_1,
        I2C_TRANSACT_2,
        I2C_TRANSACT_3,
        I2C_TRANSACT_4,

        SET_MOTOR_POWER,

        SET_MOTOR_POSITION,

        SET_MOTOR_POSITION_KP,

        SET_MOTOR_POSITION_KD,

        SET_MOTOR_DPS,

        SET_MOTOR_DPS_KP,

        SET_MOTOR_DPS_KD,

        SET_MOTOR_LIMITS,

        OFFSET_MOTOR_ENCODER,

        GET_MOTOR_A_ENCODER,
        GET_MOTOR_B_ENCODER,
        GET_MOTOR_C_ENCODER,
        GET_MOTOR_D_ENCODER,

        GET_MOTOR_A_STATUS,
        GET_MOTOR_B_STATUS,
        GET_MOTOR_C_STATUS,
        GET_MOTOR_D_STATUS,
    &#34;&#34;&#34;)

    SENSOR_TYPE = Enumeration(&#34;&#34;&#34;
        NONE = 1,
        I2C,
        CUSTOM,

        TOUCH,
        NXT_TOUCH,
        EV3_TOUCH,

        NXT_LIGHT_ON,
        NXT_LIGHT_OFF,

        NXT_COLOR_RED,
        NXT_COLOR_GREEN,
        NXT_COLOR_BLUE,
        NXT_COLOR_FULL,
        NXT_COLOR_OFF,

        NXT_ULTRASONIC,

        EV3_GYRO_ABS,
        EV3_GYRO_DPS,
        EV3_GYRO_ABS_DPS,

        EV3_COLOR_REFLECTED,
        EV3_COLOR_AMBIENT,
        EV3_COLOR_COLOR,
        EV3_COLOR_RAW_REFLECTED,
        EV3_COLOR_COLOR_COMPONENTS,

        EV3_ULTRASONIC_CM,
        EV3_ULTRASONIC_INCHES,
        EV3_ULTRASONIC_LISTEN,

        EV3_INFRARED_PROXIMITY,
        EV3_INFRARED_SEEK,
        EV3_INFRARED_REMOTE,
    &#34;&#34;&#34;)

    SENSOR_STATE = Enumeration(&#34;&#34;&#34;
        VALID_DATA,
        NOT_CONFIGURED,
        CONFIGURING,
        NO_DATA,
        I2C_ERROR,
    &#34;&#34;&#34;)

    SENSOR_CUSTOM = Enumeration(&#34;&#34;&#34;
        PIN1_9V,
        PIN5_OUT,
        PIN5_STATE,
        PIN6_OUT,
        PIN6_STATE,
        PIN1_ADC,
        PIN6_ADC,
    &#34;&#34;&#34;)
    &#34;&#34;&#34;
    Flags for use with SENSOR_TYPE.CUSTOM

    PIN1_9V
        Enable 9V out on pin 1 (for LEGO NXT Ultrasonic sensor).

    PIN5_OUT
        Set pin 5 state to output. Pin 5 will be set to input if this flag is not set.

    PIN5_STATE
        If PIN5_OUT is set, this will set the state to output high, otherwise the state will
        be output low. If PIN5_OUT is not set, this flag has no effect.

    PIN6_OUT
        Set pin 6 state to output. Pin 6 will be set to input if this flag is not set.

    PIN6_STATE
        If PIN6_OUT is set, this will set the state to output high, otherwise the state will
        be output low. If PIN6_OUT is not set, this flag has no effect.

    PIN1_ADC
        Enable the analog/digital converter on pin 1 (e.g. for NXT analog sensors).

    PIN6_ADC
        Enable the analog/digital converter on pin 6.
    &#34;&#34;&#34;

    SENSOR_CUSTOM.PIN1_9V    = 0x0002
    SENSOR_CUSTOM.PIN5_OUT   = 0x0010
    SENSOR_CUSTOM.PIN5_STATE = 0x0020
    SENSOR_CUSTOM.PIN6_OUT   = 0x0100
    SENSOR_CUSTOM.PIN6_STATE = 0x0200
    SENSOR_CUSTOM.PIN1_ADC   = 0x1000
    SENSOR_CUSTOM.PIN6_ADC   = 0x4000

    SENSOR_I2C_SETTINGS = Enumeration(&#34;&#34;&#34;
        MID_CLOCK,
        PIN1_9V,
        SAME,
        ALLOW_STRETCH_ACK,
        ALLOW_STRETCH_ANY,
    &#34;&#34;&#34;)

    SENSOR_I2C_SETTINGS.MID_CLOCK         = 0x01 # Send the clock pulse between reading and writing. Required by the NXT US sensor.
    SENSOR_I2C_SETTINGS.PIN1_9V           = 0x02 # 9v pullup on pin 1
    SENSOR_I2C_SETTINGS.SAME              = 0x04 # Keep performing the same transaction e.g. keep polling a sensor

    MOTOR_STATUS_FLAG = Enumeration(&#34;&#34;&#34;
        LOW_VOLTAGE_FLOAT,
        OVERLOADED,
    &#34;&#34;&#34;)

    MOTOR_STATUS_FLAG.LOW_VOLTAGE_FLOAT = 0x01 # If the motors are floating due to low battery voltage
    MOTOR_STATUS_FLAG.OVERLOADED        = 0x02 # If the motors aren&#39;t close to the target (applies to position control and dps speed control).

    #SUCCESS = 0
    #SPI_ERROR = 1
    #SENSOR_ERROR = 2
    #SENSOR_TYPE_ERROR = 3

    def __init__(self, addr = 1, detect = True): # Configure for the BrickPi. Optionally set the address (default to 1). Optionally disable detection (default to detect).
        &#34;&#34;&#34;
        Do any necessary configuration, and optionally detect the BrickPi3

        Optionally specify the SPI address as something other than 1
        Optionally disable the detection of the BrickPi3 hardware. This can be used for debugging and testing when the BrickPi3 would otherwise not pass the detection tests.
        &#34;&#34;&#34;

        if addr &lt; 1 or addr &gt; 255:
            raise IOError(&#34;error: SPI address must be in the range of 1 to 255&#34;)
            return

        self.SPI_Address = addr
        if detect == True:
            try:
                manufacturer = self.get_manufacturer()
                board = self.get_board()
                vfw = self.get_version_firmware()
            except IOError():
                raise IOError(&#34;No SPI response&#34;)
            if manufacturer != &#34;Dexter Industries&#34; or board != &#34;BrickPi3&#34;:
                raise IOError(&#34;No SPI response&#34;)
            if vfw.split(&#39;.&#39;)[0] != FIRMWARE_VERSION_REQUIRED.split(&#39;.&#39;)[0] or vfw.split(&#39;.&#39;)[1] != FIRMWARE_VERSION_REQUIRED.split(&#39;.&#39;)[1]:
                raise FirmwareVersionError(&#34;BrickPi3 firmware needs to be version %s but is currently version %s&#34; % (FIRMWARE_VERSION_REQUIRED, vfw))

    def spi_transfer_array(self, data_out):
        &#34;&#34;&#34;
        Conduct a SPI transaction

        Keyword arguments:
        data_out -- a list of bytes to send. The length of the list will determine how many bytes are transferred.

        Returns a list of the bytes read.
        &#34;&#34;&#34;
        return BP_SPI.xfer2(data_out)

    def spi_write_8(self, MessageType, Value):
        &#34;&#34;&#34;
        Send an 8-bit value over SPI

        Keyword arguments:
        MessageType -- the SPI message type
        Value -- the value to be sent
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, MessageType, (Value &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def spi_read_16(self, MessageType):
        &#34;&#34;&#34;
        Read a 16-bit value over SPI

        Keyword arguments:
        MessageType -- the SPI message type

        Returns:
        value
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, MessageType, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            return int((reply[4] &lt;&lt; 8) | reply[5])
        raise IOError(&#34;No SPI response&#34;)
        return

    def spi_write_16(self, MessageType, Value):
        &#34;&#34;&#34;
        Send a 16-bit value over SPI

        Keyword arguments:
        MessageType -- the SPI message type
        Value -- the value to be sent
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, MessageType, ((Value &gt;&gt; 8) &amp; 0xFF), (Value &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def spi_write_24(self, MessageType, Value):
        &#34;&#34;&#34;
        Send a 24-bit value over SPI

        Keyword arguments:
        MessageType -- the SPI message type
        Value -- the value to be sent
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, MessageType, ((Value &gt;&gt; 16) &amp; 0xFF), ((Value &gt;&gt; 8) &amp; 0xFF), (Value &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def spi_read_32(self, MessageType):
        &#34;&#34;&#34;
        Read a 32-bit value over SPI

        Keyword arguments:
        MessageType -- the SPI message type

        Returns :
        value
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, MessageType, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            return int((reply[4] &lt;&lt; 24) | (reply[5] &lt;&lt; 16) | (reply[6] &lt;&lt; 8) | reply[7])
        raise IOError(&#34;No SPI response&#34;)
        return

    def spi_write_32(self, MessageType, Value):
        &#34;&#34;&#34;
        Send a 32-bit value over SPI

        Keyword arguments:
        MessageType -- the SPI message type
        Value -- the value to be sent
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, MessageType, ((Value &gt;&gt; 24) &amp; 0xFF), ((Value &gt;&gt; 16) &amp; 0xFF), ((Value &gt;&gt; 8) &amp; 0xFF), (Value &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def get_manufacturer(self):
        &#34;&#34;&#34;
        Read the 20 charactor BrickPi3 manufacturer name

        Returns:
        BrickPi3 manufacturer name string
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.GET_MANUFACTURER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            name = &#34;&#34;
            for c in range(4, 24):
                if reply[c] != 0:
                    name += chr(reply[c])
                else:
                    break
            return name
        raise IOError(&#34;No SPI response&#34;)
        return

    def get_board(self):
        &#34;&#34;&#34;
        Read the 20 charactor BrickPi3 board name

        Returns:
        BrickPi3 board name string
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.GET_NAME, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            name = &#34;&#34;
            for c in range(4, 24):
                if reply[c] != 0:
                    name += chr(reply[c])
                else:
                    break
            return name
        raise IOError(&#34;No SPI response&#34;)
        return

    def get_version_hardware(self):
        &#34;&#34;&#34;
        Read the hardware version

        Returns:
        hardware version
        &#34;&#34;&#34;
        version = self.spi_read_32(self.BPSPI_MESSAGE_TYPE.GET_HARDWARE_VERSION)
        return (&#34;%d.%d.%d&#34; % ((version / 1000000), ((version / 1000) % 1000), (version % 1000)))

    def get_version_firmware(self):
        &#34;&#34;&#34;
        Read the firmware version

        Returns:
        firmware version
        &#34;&#34;&#34;
        version = self.spi_read_32(self.BPSPI_MESSAGE_TYPE.GET_FIRMWARE_VERSION)
        return (&#34;%d.%d.%d&#34; % ((version / 1000000), ((version / 1000) % 1000), (version % 1000)))

    def get_id(self):
        &#34;&#34;&#34;
        Read the 128-bit BrickPi hardware serial number

        Returns:
        serial number as 32 char HEX formatted string
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.GET_ID, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            return (&#34;%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X&#34; % (reply[4], reply[5], reply[6], reply[7], reply[8], reply[9], reply[10], reply[11], reply[12], reply[13], reply[14], reply[15], reply[16], reply[17], reply[18], reply[19]))
        raise IOError(&#34;No SPI response&#34;)
        return

    def set_led(self, value):
        &#34;&#34;&#34;
        Control the onboard LED

        Keyword arguments:
        value -- the value (in percent) to set the LED brightness to. -1 returns control of the LED to the firmware.
        &#34;&#34;&#34;
        self.spi_write_8(self.BPSPI_MESSAGE_TYPE.SET_LED, value)

    def get_voltage_3v3(self):
        &#34;&#34;&#34;
        Get the 3.3v circuit voltage

        Returns:
        3.3v circuit voltage
        &#34;&#34;&#34;
        value = self.spi_read_16(self.BPSPI_MESSAGE_TYPE.GET_VOLTAGE_3V3)
        return (value / 1000.0)

    def get_voltage_5v(self):
        &#34;&#34;&#34;
        Get the 5v circuit voltage

        Returns:
        5v circuit voltage
        &#34;&#34;&#34;
        value = self.spi_read_16(self.BPSPI_MESSAGE_TYPE.GET_VOLTAGE_5V)
        return (value / 1000.0)

    def get_voltage_9v(self):
        &#34;&#34;&#34;
        Get the 9v circuit voltage

        Returns:
        9v circuit voltage
        &#34;&#34;&#34;
        value = self.spi_read_16(self.BPSPI_MESSAGE_TYPE.GET_VOLTAGE_9V)
        return (value / 1000.0)

    def get_voltage_battery(self):
        &#34;&#34;&#34;
        Get the battery voltage

        Returns:
        battery voltage
        &#34;&#34;&#34;
        value = self.spi_read_16(self.BPSPI_MESSAGE_TYPE.GET_VOLTAGE_VCC)
        return (value / 1000.0)

    def set_sensor_type(self, port, type, params = 0):
        &#34;&#34;&#34;
        Set the sensor type

        Keyword arguments:
        port -- The sensor port(s). PORT_1, PORT_2, PORT_3, and/or PORT_4.
        type -- The sensor type
        params = 0 -- the parameters needed for some sensor types.

        params is used for the following sensor types:
            CUSTOM -- a 16-bit integer used to configure the hardware.
            I2C -- a list of settings:
                params[0] -- Settings/flags
                params[1] -- target Speed in microseconds (0-255). Realistically the speed will vary.
                if SENSOR_I2C_SETTINGS_SAME flag set in I2C Settings:
                    params[2] -- Delay in microseconds between transactions.
                    params[3] -- Address
                    params[4] -- List of bytes to write
                    params[5] -- Number of bytes to read
        &#34;&#34;&#34;
        for p in range(4):
            if port &amp; (1 &lt;&lt; p):
                self.SensorType[p] = type
        if(type == self.SENSOR_TYPE.CUSTOM):
            outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_SENSOR_TYPE, int(port), type, ((params[0] &gt;&gt; 8) &amp; 0xFF), (params[0] &amp; 0xFF)]

            #self.spi_write_24(self.BPSPI_MESSAGE_TYPE.SET_SENSOR_TYPE, int(port), ((type &lt;&lt; 16) + (params[0])))
        elif(type == self.SENSOR_TYPE.I2C):
            if len(params) &gt;= 2:
                outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_SENSOR_TYPE, int(port), type, params[0], params[1]] # Settings, SpeedUS
                if params[0] &amp; self.SENSOR_I2C_SETTINGS.SAME and len(params) &gt;= 6:
                    outArray.append((params[2] &gt;&gt; 24) &amp; 0xFF) # DelayUS
                    outArray.append((params[2] &gt;&gt; 16) &amp; 0xFF) #   &#39;&#39;
                    outArray.append((params[2] &gt;&gt; 8) &amp; 0xFF)  #   &#39;&#39;
                    outArray.append(params[2] &amp; 0xFF)         #   &#39;&#39;
                    outArray.append(params[3] &amp; 0xFF)   # Address
                    outArray.append(params[5] &amp; 0xFF)   # InBytes
                    for p in range(4):
                        if port &amp; (1 &lt;&lt; p):
                            self.I2CInBytes[p] = params[5] &amp; 0xFF
                    outArray.append(len(params[4]))     # OutBytes
                    outArray.extend(params[4])          # OutArray
        else:
            outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_SENSOR_TYPE, int(port), type]

        self.spi_transfer_array(outArray)

    def transact_i2c(self, port, Address, OutArray, InBytes):
        &#34;&#34;&#34;
        Conduct an I2C transaction

        Keyword arguments:
        port -- The sensor port (one at a time). PORT_1, PORT_2, PORT_3, or PORT_4.
        Address -- The I2C address for the device. Bits 1-7, not 0-6.
        OutArray -- A list of bytes to write to the device
        InBytes -- The number of bytes to read from the device
        &#34;&#34;&#34;
        if port == self.PORT_1:
            message_type = self.BPSPI_MESSAGE_TYPE.I2C_TRANSACT_1
            port_index = 0
        elif port == self.PORT_2:
            message_type = self.BPSPI_MESSAGE_TYPE.I2C_TRANSACT_2
            port_index = 1
        elif port == self.PORT_3:
            message_type = self.BPSPI_MESSAGE_TYPE.I2C_TRANSACT_3
            port_index = 2
        elif port == self.PORT_4:
            message_type = self.BPSPI_MESSAGE_TYPE.I2C_TRANSACT_4
            port_index = 3
        else:
            raise IOError(&#34;transact_i2c error. Must be one sensor port at a time. PORT_1, PORT_2, PORT_3, or PORT_4.&#34;)
            return

        if self.SensorType[port_index] != self.SENSOR_TYPE.I2C:
            return
        outArray = [self.SPI_Address, message_type, Address, InBytes]
        self.I2CInBytes[port_index] = InBytes
        OutBytes = len(OutArray)
        if(OutBytes &gt; self.I2C_LENGTH_LIMIT):
            outArray.append(self.I2C_LENGTH_LIMIT)
            for b in range(self.I2C_LENGTH_LIMIT):
                outArray.append(OutArray[b])
        else:
            outArray.append(OutBytes)
            outArray.extend(OutArray)
        self.spi_transfer_array(outArray)

    def get_sensor(self, port):
        &#34;&#34;&#34;
        Read a sensor value

        Keyword arguments:
        port -- The sensor port (one at a time). PORT_1, PORT_2, PORT_3, or PORT_4.

        Returns the value(s) for the specified sensor.
            The following sensor types each return a single value:
                NONE ----------------------- 0
                TOUCH ---------------------- 0 or 1 (released or pressed)
                NXT_TOUCH ------------------ 0 or 1 (released or pressed)
                EV3_TOUCH ------------------ 0 or 1 (released or pressed)
                NXT_ULTRASONIC ------------- distance in CM
                NXT_LIGHT_ON  -------------- reflected light
                NXT_LIGHT_OFF -------------- ambient light
                NXT_COLOR_RED -------------- red reflected light
                NXT_COLOR_GREEN ------------ green reflected light
                NXT_COLOR_BLUE ------------- blue reflected light
                NXT_COLOR_OFF -------------- ambient light
                EV3_GYRO_ABS --------------- absolute rotation position in degrees
                EV3_GYRO_DPS --------------- rotation rate in degrees per second
                EV3_COLOR_REFLECTED -------- red reflected light
                EV3_COLOR_AMBIENT ---------- ambient light
                EV3_COLOR_COLOR ------------ detected color
                EV3_ULTRASONIC_CM ---------- distance in CM
                EV3_ULTRASONIC_INCHES ------ distance in inches
                EV3_ULTRASONIC_LISTEN ------ 0 or 1 (no other ultrasonic sensors or another ultrasonic sensor detected)
                EV3_INFRARED_PROXIMITY ----- distance 0-100%

            The following sensor types each return a list of values
                CUSTOM --------------------- Pin 1 ADC (5v scale from 0 to 4095), Pin 6 ADC (3.3v scale from 0 to 4095), Pin 5 digital, Pin 6 digital
                I2C ------------------------ the I2C bytes read
                NXT_COLOR_FULL ------------- detected color, red light reflected, green light reflected, blue light reflected, ambient light
                EV3_GYRO_ABS_DPS ----------- absolute rotation position in degrees, rotation rate in degrees per second
                EV3_COLOR_RAW_REFLECTED ---- red reflected light, unknown value (maybe a raw ambient value?)
                EV3_COLOR_COLOR_COMPONENTS - red reflected light, green reflected light, blue reflected light, unknown value (maybe a raw value?)
                EV3_INFRARED_SEEK ---------- a list for each of the four channels. For each channel heading (-25 to 25), distance (-128 or 0 to 100)
                EV3_INFRARED_REMOTE -------- a list for each of the four channels. For each channel red up, red down, blue up, blue down, boadcast

        &#34;&#34;&#34;
        if port == self.PORT_1:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_1
            port_index = 0
        elif port == self.PORT_2:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_2
            port_index = 1
        elif port == self.PORT_3:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_3
            port_index = 2
        elif port == self.PORT_4:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_4
            port_index = 3
        else:
            raise IOError(&#34;get_sensor error. Must be one sensor port at a time. PORT_1, PORT_2, PORT_3, or PORT_4.&#34;)
            return

        if self.SensorType[port_index] == self.SENSOR_TYPE.CUSTOM:
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    return [(((reply[8] &amp; 0x0F) &lt;&lt; 8) | reply[9]), (((reply[8] &gt;&gt; 4) &amp; 0x0F) | (reply[7] &lt;&lt; 4)), (reply[6] &amp; 0x01), ((reply[6] &gt;&gt; 1) &amp; 0x01)]
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif self.SensorType[port_index] == self.SENSOR_TYPE.I2C:
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0]
            for b in range(self.I2CInBytes[port_index]):
                outArray.append(0)
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA and len(reply) - 6 == self.I2CInBytes[port_index]):
                    values = []
                    for b in range(6, len(reply)):
                        values.append(reply[b])
                    return values
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif(self.SensorType[port_index] == self.SENSOR_TYPE.TOUCH
          or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_TOUCH
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_TOUCH
          or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_ULTRASONIC
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_REFLECTED
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_AMBIENT
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_COLOR
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_LISTEN
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_INFRARED_PROXIMITY):
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if((reply[4] == self.SensorType[port_index] or (self.SensorType[port_index] == self.SENSOR_TYPE.TOUCH and (reply[4] == self.SENSOR_TYPE.NXT_TOUCH or reply[4] == self.SENSOR_TYPE.EV3_TOUCH))) and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    return reply[6]
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_FULL:
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    return [reply[6], ((reply[7] &lt;&lt; 2) | ((reply[11] &gt;&gt; 6) &amp; 0x03)), ((reply[8] &lt;&lt; 2) | ((reply[11] &gt;&gt; 4) &amp; 0x03)), ((reply[9] &lt;&lt; 2) | ((reply[11] &gt;&gt; 2) &amp; 0x03)), ((reply[10] &lt;&lt; 2) | (reply[11] &amp; 0x03))]
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif(self.SensorType[port_index] == self.SENSOR_TYPE.NXT_LIGHT_ON
          or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_LIGHT_OFF
          or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_RED
          or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_GREEN
          or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_BLUE
          or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_OFF
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_ABS
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_DPS
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_CM
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_INCHES):
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    value = int((reply[6] &lt;&lt; 8) | reply[7])
                    if((self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_ABS
                    or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_DPS)
                    and (value &amp; 0x8000)):
                        value = value - 0x10000
                    elif(self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_CM
                      or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_INCHES):
                        value = value / 10
                    return value
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif(self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_RAW_REFLECTED
          or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_ABS_DPS):
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    results = [int((reply[6] &lt;&lt; 8) | reply[7]), int((reply[8] &lt;&lt; 8) | reply[9])]
                    if self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_ABS_DPS:
                        for r in range(len(results)):
                            if results[r] &gt;= 0x8000:
                                results[r] = results[r] - 0x10000
                    return results
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif(self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_COLOR_COMPONENTS):
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    return [int((reply[6] &lt;&lt; 8) | reply[7]), int((reply[8] &lt;&lt; 8) | reply[9]), int((reply[10] &lt;&lt; 8) | reply[11]), int((reply[12] &lt;&lt; 8) | reply[13])]
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif(self.SensorType[port_index] == self.SENSOR_TYPE.EV3_INFRARED_SEEK):
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    results = [[int(reply[6]), int(reply[7])], [int(reply[8]), int(reply[9])], [int(reply[10]), int(reply[11])], [int(reply[12]), int(reply[13])]]
                    for c in range(len(results)):
                        for v in range(len(results[c])):
                            if results[c][v] &gt;= 0x80:
                                results[c][v] = results[c][v] - 0x100
                    return results
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        elif(self.SensorType[port_index] == self.SENSOR_TYPE.EV3_INFRARED_REMOTE):
            outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0]
            reply = self.spi_transfer_array(outArray)
            if(reply[3] == 0xA5):
                if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                    results = [0, 0, 0, 0]
                    for r in range(len(results)):
                        value = int(reply[6 + r])
                        if value == 1:
                            results[r] = [1, 0, 0, 0, 0]
                        elif value == 2:
                            results[r] = [0, 1, 0, 0, 0]
                        elif value == 3:
                            results[r] = [0, 0, 1, 0, 0]
                        elif value == 4:
                            results[r] = [0, 0, 0, 1, 0]
                        elif value == 5:
                            results[r] = [1, 0, 1, 0, 0]
                        elif value == 6:
                            results[r] = [1, 0, 0, 1, 0]
                        elif value == 7:
                            results[r] = [0, 1, 1, 0, 0]
                        elif value == 8:
                            results[r] = [0, 1, 0, 1, 0]
                        elif value == 9:
                            results[r] = [0, 0, 0, 0, 1]
                        elif value == 10:
                            results[r] = [1, 1, 0, 0, 0]
                        elif value == 11:
                            results[r] = [0, 0, 1, 1, 0]
                        else:
                            results[r] = [0, 0, 0, 0, 0]
                    return results
                else:
                    raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                    return
            else:
                raise IOError(&#34;get_sensor error: No SPI response&#34;)
                return

        raise IOError(&#34;get_sensor error: Sensor not configured or not supported.&#34;)
        return # sensor not configured or not supported.

    def set_motor_power(self, port, power):
        &#34;&#34;&#34;
        Set the motor power in percent

        Keyword arguments:
        port -- The Motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        power -- The power from -100 to 100, or -128 for float
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_POWER, int(port), int(power)]
        self.spi_transfer_array(outArray)

    def set_motor_position(self, port, position):
        &#34;&#34;&#34;
        Set the motor target position in degrees

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        position -- The target position
        &#34;&#34;&#34;
        position = int(position)
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_POSITION, int(port), ((position &gt;&gt; 24) &amp; 0xFF), ((position &gt;&gt; 16) &amp; 0xFF), ((position &gt;&gt; 8) &amp; 0xFF), (position &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def set_motor_position_relative(self, port, degrees):
        &#34;&#34;&#34;
        Set the relative motor target position in degrees. Current position plus the specified degrees.

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        degrees -- The relative target position in degrees
        &#34;&#34;&#34;
        for p in range(4):
            if port &amp; (1 &lt;&lt; p):
                self.set_motor_position((1 &lt;&lt; p), (self.get_motor_encoder(1 &lt;&lt; p) + degrees))

    def set_motor_position_kp(self, port, kp = 25):
        &#34;&#34;&#34;
        Set the motor target position KP constant

        If you set kp higher, the motor will be more responsive to errors in position, at the cost of perhaps overshooting and oscillating.
        kd slows down the motor as it approaches the target, and helps to prevent overshoot.
        In general, if you increase kp, you should also increase kd to keep the motor from overshooting and oscillating.

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        kp -- The KP constant (default 25)
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_POSITION_KP, int(port), int(kp)]
        self.spi_transfer_array(outArray)

    def set_motor_position_kd(self, port, kd = 70):
        &#34;&#34;&#34;
        Set the motor target position KD constant

        If you set kp higher, the motor will be more responsive to errors in position, at the cost of perhaps overshooting and oscillating.
        kd slows down the motor as it approaches the target, and helps to prevent overshoot.
        In general, if you increase kp, you should also increase kd to keep the motor from overshooting and oscillating.

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        kd -- The KD constant (default 70)
        &#34;&#34;&#34;
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_POSITION_KD, int(port), int(kd)]
        self.spi_transfer_array(outArray)

    def set_motor_dps(self, port, dps):
        &#34;&#34;&#34;
        Set the motor target speed in degrees per second

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        dps -- The target speed in degrees per second
        &#34;&#34;&#34;
        dps = int(dps)
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_DPS, int(port), ((dps &gt;&gt; 8) &amp; 0xFF), (dps &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def set_motor_limits(self, port, power = 0, dps = 0):
        &#34;&#34;&#34;
        Set the motor speed limit

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        power -- The power limit in percent (0 to 100), with 0 being no limit (100)
        dps -- The speed limit in degrees per second, with 0 being no limit
        &#34;&#34;&#34;
        dps = int(dps)
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_LIMITS, int(port), int(power), ((dps &gt;&gt; 8) &amp; 0xFF), (dps &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def get_motor_status(self, port):
        &#34;&#34;&#34;
        Read a motor status

        Keyword arguments:
        port -- The motor port (one at a time). PORT_A, PORT_B, PORT_C, or PORT_D.

        Returns a list:
            flags -- 8-bits of bit-flags that indicate motor status:
                bit 0 -- LOW_VOLTAGE_FLOAT - The motors are automatically disabled because the battery voltage is too low
                bit 1 -- OVERLOADED - The motors aren&#39;t close to the target (applies to position control and dps speed control).
            power -- the raw PWM power in percent (-100 to 100)
            encoder -- The encoder position
            dps -- The current speed in Degrees Per Second
        &#34;&#34;&#34;
        if port == self.PORT_A:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_A_STATUS
        elif port == self.PORT_B:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_B_STATUS
        elif port == self.PORT_C:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_C_STATUS
        elif port == self.PORT_D:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_D_STATUS
        else:
            raise IOError(&#34;get_motor_status error. Must be one motor port at a time. PORT_A, PORT_B, PORT_C, or PORT_D.&#34;)
            return

        outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            speed = int(reply[5])
            if speed &amp; 0x80:
                speed = speed - 0x100

            encoder = int((reply[6] &lt;&lt; 24) | (reply[7] &lt;&lt; 16) | (reply[8] &lt;&lt; 8) | reply[9])
            if encoder &amp; 0x80000000: # MT was 0x10000000, but I think it should be 0x80000000
                encoder = int(encoder - 0x100000000)

            dps = int((reply[10] &lt;&lt; 8) | reply[11])
            if dps &amp; 0x8000:
                dps = dps - 0x10000

            return [reply[4], speed, encoder, dps]
        raise IOError(&#34;No SPI response&#34;)
        return

    def get_motor_encoder(self, port):
        &#34;&#34;&#34;
        Read a motor encoder in degrees

        Keyword arguments:
        port -- The motor port (one at a time). PORT_A, PORT_B, PORT_C, or PORT_D.

        Returns the encoder position in degrees
        &#34;&#34;&#34;
        if port == self.PORT_A:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_A_ENCODER
        elif port == self.PORT_B:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_B_ENCODER
        elif port == self.PORT_C:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_C_ENCODER
        elif port == self.PORT_D:
            message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_D_ENCODER
        else:
            raise IOError(&#34;get_motor_encoder error. Must be one motor port at a time. PORT_A, PORT_B, PORT_C, or PORT_D.&#34;)
            return

        encoder = self.spi_read_32(message_type)
        if encoder &amp; 0x80000000:
            encoder = int(encoder - 0x100000000)
        return int(encoder)

    def offset_motor_encoder(self, port, position):
        &#34;&#34;&#34;
        Offset a motor encoder

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        offset -- The encoder offset

        You can zero the encoder by offsetting it by the current position
        &#34;&#34;&#34;
        position = int(position)
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.OFFSET_MOTOR_ENCODER, int(port), ((position &gt;&gt; 24) &amp; 0xFF), ((position &gt;&gt; 16) &amp; 0xFF), ((position &gt;&gt; 8) &amp; 0xFF), (position &amp; 0xFF)]
        self.spi_transfer_array(outArray)

    def reset_motor_encoder(self, port):
        &#34;&#34;&#34;
        Reset motor encoder(s) to 0

        Keyword arguments:
        port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
        &#34;&#34;&#34;
        if port &amp; self.PORT_A:
            self.offset_motor_encoder(self.PORT_A, self.get_motor_encoder(self.PORT_A))

        if port &amp; self.PORT_B:
            self.offset_motor_encoder(self.PORT_B, self.get_motor_encoder(self.PORT_B))

        if port &amp; self.PORT_C:
            self.offset_motor_encoder(self.PORT_C, self.get_motor_encoder(self.PORT_C))

        if port &amp; self.PORT_D:
            self.offset_motor_encoder(self.PORT_D, self.get_motor_encoder(self.PORT_D))

    def reset_all(self):
        &#34;&#34;&#34;
        Reset the BrickPi. Set all the sensors&#39; type to NONE, set the motors to float, and motors&#39; limits and constants to default, and return control of the LED to the firmware.
        &#34;&#34;&#34;
        # reset all sensors
        self.set_sensor_type(self.PORT_1 + self.PORT_2 + self.PORT_3 + self.PORT_4, self.SENSOR_TYPE.NONE)

        # turn off all motors
        self.set_motor_power(self.PORT_A + self.PORT_B + self.PORT_C + self.PORT_D, self.MOTOR_FLOAT)

        # reset motor limits
        self.set_motor_limits(self.PORT_A + self.PORT_B + self.PORT_C + self.PORT_D)

        # reset motor kP and kD constants
        self.set_motor_position_kp(self.PORT_A + self.PORT_B + self.PORT_C + self.PORT_D)
        self.set_motor_position_kd(self.PORT_A + self.PORT_B + self.PORT_C + self.PORT_D)

        # return the LED to the control of the FW
        self.set_led(-1)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="brickpi3.BrickPi3.BPSPI_MESSAGE_TYPE"><code class="name">var <span class="ident">BPSPI_MESSAGE_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.I2CInBytes"><code class="name">var <span class="ident">I2CInBytes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.I2C_LENGTH_LIMIT"><code class="name">var <span class="ident">I2C_LENGTH_LIMIT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.MOTOR_FLOAT"><code class="name">var <span class="ident">MOTOR_FLOAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.MOTOR_STATUS_FLAG"><code class="name">var <span class="ident">MOTOR_STATUS_FLAG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.PORT_1"><code class="name">var <span class="ident">PORT_1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.PORT_2"><code class="name">var <span class="ident">PORT_2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.PORT_3"><code class="name">var <span class="ident">PORT_3</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.PORT_4"><code class="name">var <span class="ident">PORT_4</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.PORT_A"><code class="name">var <span class="ident">PORT_A</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.PORT_B"><code class="name">var <span class="ident">PORT_B</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.PORT_C"><code class="name">var <span class="ident">PORT_C</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.PORT_D"><code class="name">var <span class="ident">PORT_D</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.SENSOR_CUSTOM"><code class="name">var <span class="ident">SENSOR_CUSTOM</span></code></dt>
<dd>
<div class="desc"><p>Flags for use with SENSOR_TYPE.CUSTOM</p>
<p>PIN1_9V
Enable 9V out on pin 1 (for LEGO NXT Ultrasonic sensor).</p>
<p>PIN5_OUT
Set pin 5 state to output. Pin 5 will be set to input if this flag is not set.</p>
<p>PIN5_STATE
If PIN5_OUT is set, this will set the state to output high, otherwise the state will
be output low. If PIN5_OUT is not set, this flag has no effect.</p>
<p>PIN6_OUT
Set pin 6 state to output. Pin 6 will be set to input if this flag is not set.</p>
<p>PIN6_STATE
If PIN6_OUT is set, this will set the state to output high, otherwise the state will
be output low. If PIN6_OUT is not set, this flag has no effect.</p>
<p>PIN1_ADC
Enable the analog/digital converter on pin 1 (e.g. for NXT analog sensors).</p>
<p>PIN6_ADC
Enable the analog/digital converter on pin 6.</p></div>
</dd>
<dt id="brickpi3.BrickPi3.SENSOR_I2C_SETTINGS"><code class="name">var <span class="ident">SENSOR_I2C_SETTINGS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.SENSOR_STATE"><code class="name">var <span class="ident">SENSOR_STATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.SENSOR_TYPE"><code class="name">var <span class="ident">SENSOR_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="brickpi3.BrickPi3.SensorType"><code class="name">var <span class="ident">SensorType</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="brickpi3.BrickPi3.get_board"><code class="name flex">
<span>def <span class="ident">get_board</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the 20 charactor BrickPi3 board name</p>
<p>Returns:
BrickPi3 board name string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_board(self):
    &#34;&#34;&#34;
    Read the 20 charactor BrickPi3 board name

    Returns:
    BrickPi3 board name string
    &#34;&#34;&#34;
    outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.GET_NAME, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    reply = self.spi_transfer_array(outArray)
    if(reply[3] == 0xA5):
        name = &#34;&#34;
        for c in range(4, 24):
            if reply[c] != 0:
                name += chr(reply[c])
            else:
                break
        return name
    raise IOError(&#34;No SPI response&#34;)
    return</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.get_id"><code class="name flex">
<span>def <span class="ident">get_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the 128-bit BrickPi hardware serial number</p>
<p>Returns:
serial number as 32 char HEX formatted string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id(self):
    &#34;&#34;&#34;
    Read the 128-bit BrickPi hardware serial number

    Returns:
    serial number as 32 char HEX formatted string
    &#34;&#34;&#34;
    outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.GET_ID, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    reply = self.spi_transfer_array(outArray)
    if(reply[3] == 0xA5):
        return (&#34;%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X&#34; % (reply[4], reply[5], reply[6], reply[7], reply[8], reply[9], reply[10], reply[11], reply[12], reply[13], reply[14], reply[15], reply[16], reply[17], reply[18], reply[19]))
    raise IOError(&#34;No SPI response&#34;)
    return</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.get_manufacturer"><code class="name flex">
<span>def <span class="ident">get_manufacturer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the 20 charactor BrickPi3 manufacturer name</p>
<p>Returns:
BrickPi3 manufacturer name string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_manufacturer(self):
    &#34;&#34;&#34;
    Read the 20 charactor BrickPi3 manufacturer name

    Returns:
    BrickPi3 manufacturer name string
    &#34;&#34;&#34;
    outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.GET_MANUFACTURER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    reply = self.spi_transfer_array(outArray)
    if(reply[3] == 0xA5):
        name = &#34;&#34;
        for c in range(4, 24):
            if reply[c] != 0:
                name += chr(reply[c])
            else:
                break
        return name
    raise IOError(&#34;No SPI response&#34;)
    return</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.get_motor_encoder"><code class="name flex">
<span>def <span class="ident">get_motor_encoder</span></span>(<span>self, port)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a motor encoder in degrees</p>
<p>Keyword arguments:
port &ndash; The motor port (one at a time). PORT_A, PORT_B, PORT_C, or PORT_D.</p>
<p>Returns the encoder position in degrees</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_motor_encoder(self, port):
    &#34;&#34;&#34;
    Read a motor encoder in degrees

    Keyword arguments:
    port -- The motor port (one at a time). PORT_A, PORT_B, PORT_C, or PORT_D.

    Returns the encoder position in degrees
    &#34;&#34;&#34;
    if port == self.PORT_A:
        message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_A_ENCODER
    elif port == self.PORT_B:
        message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_B_ENCODER
    elif port == self.PORT_C:
        message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_C_ENCODER
    elif port == self.PORT_D:
        message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_D_ENCODER
    else:
        raise IOError(&#34;get_motor_encoder error. Must be one motor port at a time. PORT_A, PORT_B, PORT_C, or PORT_D.&#34;)
        return

    encoder = self.spi_read_32(message_type)
    if encoder &amp; 0x80000000:
        encoder = int(encoder - 0x100000000)
    return int(encoder)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.get_motor_status"><code class="name flex">
<span>def <span class="ident">get_motor_status</span></span>(<span>self, port)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a motor status</p>
<p>Keyword arguments:
port &ndash; The motor port (one at a time). PORT_A, PORT_B, PORT_C, or PORT_D.</p>
<p>Returns a list:
flags &ndash; 8-bits of bit-flags that indicate motor status:
bit 0 &ndash; LOW_VOLTAGE_FLOAT - The motors are automatically disabled because the battery voltage is too low
bit 1 &ndash; OVERLOADED - The motors aren't close to the target (applies to position control and dps speed control).
power &ndash; the raw PWM power in percent (-100 to 100)
encoder &ndash; The encoder position
dps &ndash; The current speed in Degrees Per Second</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_motor_status(self, port):
    &#34;&#34;&#34;
    Read a motor status

    Keyword arguments:
    port -- The motor port (one at a time). PORT_A, PORT_B, PORT_C, or PORT_D.

    Returns a list:
        flags -- 8-bits of bit-flags that indicate motor status:
            bit 0 -- LOW_VOLTAGE_FLOAT - The motors are automatically disabled because the battery voltage is too low
            bit 1 -- OVERLOADED - The motors aren&#39;t close to the target (applies to position control and dps speed control).
        power -- the raw PWM power in percent (-100 to 100)
        encoder -- The encoder position
        dps -- The current speed in Degrees Per Second
    &#34;&#34;&#34;
    if port == self.PORT_A:
        message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_A_STATUS
    elif port == self.PORT_B:
        message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_B_STATUS
    elif port == self.PORT_C:
        message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_C_STATUS
    elif port == self.PORT_D:
        message_type = self.BPSPI_MESSAGE_TYPE.GET_MOTOR_D_STATUS
    else:
        raise IOError(&#34;get_motor_status error. Must be one motor port at a time. PORT_A, PORT_B, PORT_C, or PORT_D.&#34;)
        return

    outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    reply = self.spi_transfer_array(outArray)
    if(reply[3] == 0xA5):
        speed = int(reply[5])
        if speed &amp; 0x80:
            speed = speed - 0x100

        encoder = int((reply[6] &lt;&lt; 24) | (reply[7] &lt;&lt; 16) | (reply[8] &lt;&lt; 8) | reply[9])
        if encoder &amp; 0x80000000: # MT was 0x10000000, but I think it should be 0x80000000
            encoder = int(encoder - 0x100000000)

        dps = int((reply[10] &lt;&lt; 8) | reply[11])
        if dps &amp; 0x8000:
            dps = dps - 0x10000

        return [reply[4], speed, encoder, dps]
    raise IOError(&#34;No SPI response&#34;)
    return</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.get_sensor"><code class="name flex">
<span>def <span class="ident">get_sensor</span></span>(<span>self, port)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a sensor value</p>
<p>Keyword arguments:
port &ndash; The sensor port (one at a time). PORT_1, PORT_2, PORT_3, or PORT_4.</p>
<p>Returns the value(s) for the specified sensor.
The following sensor types each return a single value:
NONE ----------------------- 0
TOUCH ---------------------- 0 or 1 (released or pressed)
NXT_TOUCH ------------------ 0 or 1 (released or pressed)
EV3_TOUCH ------------------ 0 or 1 (released or pressed)
NXT_ULTRASONIC ------------- distance in CM
NXT_LIGHT_ON
-------------- reflected light
NXT_LIGHT_OFF -------------- ambient light
NXT_COLOR_RED -------------- red reflected light
NXT_COLOR_GREEN ------------ green reflected light
NXT_COLOR_BLUE ------------- blue reflected light
NXT_COLOR_OFF -------------- ambient light
EV3_GYRO_ABS --------------- absolute rotation position in degrees
EV3_GYRO_DPS --------------- rotation rate in degrees per second
EV3_COLOR_REFLECTED -------- red reflected light
EV3_COLOR_AMBIENT ---------- ambient light
EV3_COLOR_COLOR ------------ detected color
EV3_ULTRASONIC_CM ---------- distance in CM
EV3_ULTRASONIC_INCHES ------ distance in inches
EV3_ULTRASONIC_LISTEN ------ 0 or 1 (no other ultrasonic sensors or another ultrasonic sensor detected)
EV3_INFRARED_PROXIMITY ----- distance 0-100%</p>
<pre><code>The following sensor types each return a list of values
    CUSTOM --------------------- Pin 1 ADC (5v scale from 0 to 4095), Pin 6 ADC (3.3v scale from 0 to 4095), Pin 5 digital, Pin 6 digital
    I2C ------------------------ the I2C bytes read
    NXT_COLOR_FULL ------------- detected color, red light reflected, green light reflected, blue light reflected, ambient light
    EV3_GYRO_ABS_DPS ----------- absolute rotation position in degrees, rotation rate in degrees per second
    EV3_COLOR_RAW_REFLECTED ---- red reflected light, unknown value (maybe a raw ambient value?)
    EV3_COLOR_COLOR_COMPONENTS - red reflected light, green reflected light, blue reflected light, unknown value (maybe a raw value?)
    EV3_INFRARED_SEEK ---------- a list for each of the four channels. For each channel heading (-25 to 25), distance (-128 or 0 to 100)
    EV3_INFRARED_REMOTE -------- a list for each of the four channels. For each channel red up, red down, blue up, blue down, boadcast
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sensor(self, port):
    &#34;&#34;&#34;
    Read a sensor value

    Keyword arguments:
    port -- The sensor port (one at a time). PORT_1, PORT_2, PORT_3, or PORT_4.

    Returns the value(s) for the specified sensor.
        The following sensor types each return a single value:
            NONE ----------------------- 0
            TOUCH ---------------------- 0 or 1 (released or pressed)
            NXT_TOUCH ------------------ 0 or 1 (released or pressed)
            EV3_TOUCH ------------------ 0 or 1 (released or pressed)
            NXT_ULTRASONIC ------------- distance in CM
            NXT_LIGHT_ON  -------------- reflected light
            NXT_LIGHT_OFF -------------- ambient light
            NXT_COLOR_RED -------------- red reflected light
            NXT_COLOR_GREEN ------------ green reflected light
            NXT_COLOR_BLUE ------------- blue reflected light
            NXT_COLOR_OFF -------------- ambient light
            EV3_GYRO_ABS --------------- absolute rotation position in degrees
            EV3_GYRO_DPS --------------- rotation rate in degrees per second
            EV3_COLOR_REFLECTED -------- red reflected light
            EV3_COLOR_AMBIENT ---------- ambient light
            EV3_COLOR_COLOR ------------ detected color
            EV3_ULTRASONIC_CM ---------- distance in CM
            EV3_ULTRASONIC_INCHES ------ distance in inches
            EV3_ULTRASONIC_LISTEN ------ 0 or 1 (no other ultrasonic sensors or another ultrasonic sensor detected)
            EV3_INFRARED_PROXIMITY ----- distance 0-100%

        The following sensor types each return a list of values
            CUSTOM --------------------- Pin 1 ADC (5v scale from 0 to 4095), Pin 6 ADC (3.3v scale from 0 to 4095), Pin 5 digital, Pin 6 digital
            I2C ------------------------ the I2C bytes read
            NXT_COLOR_FULL ------------- detected color, red light reflected, green light reflected, blue light reflected, ambient light
            EV3_GYRO_ABS_DPS ----------- absolute rotation position in degrees, rotation rate in degrees per second
            EV3_COLOR_RAW_REFLECTED ---- red reflected light, unknown value (maybe a raw ambient value?)
            EV3_COLOR_COLOR_COMPONENTS - red reflected light, green reflected light, blue reflected light, unknown value (maybe a raw value?)
            EV3_INFRARED_SEEK ---------- a list for each of the four channels. For each channel heading (-25 to 25), distance (-128 or 0 to 100)
            EV3_INFRARED_REMOTE -------- a list for each of the four channels. For each channel red up, red down, blue up, blue down, boadcast

    &#34;&#34;&#34;
    if port == self.PORT_1:
        message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_1
        port_index = 0
    elif port == self.PORT_2:
        message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_2
        port_index = 1
    elif port == self.PORT_3:
        message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_3
        port_index = 2
    elif port == self.PORT_4:
        message_type = self.BPSPI_MESSAGE_TYPE.GET_SENSOR_4
        port_index = 3
    else:
        raise IOError(&#34;get_sensor error. Must be one sensor port at a time. PORT_1, PORT_2, PORT_3, or PORT_4.&#34;)
        return

    if self.SensorType[port_index] == self.SENSOR_TYPE.CUSTOM:
        outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                return [(((reply[8] &amp; 0x0F) &lt;&lt; 8) | reply[9]), (((reply[8] &gt;&gt; 4) &amp; 0x0F) | (reply[7] &lt;&lt; 4)), (reply[6] &amp; 0x01), ((reply[6] &gt;&gt; 1) &amp; 0x01)]
            else:
                raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                return
        else:
            raise IOError(&#34;get_sensor error: No SPI response&#34;)
            return

    elif self.SensorType[port_index] == self.SENSOR_TYPE.I2C:
        outArray = [self.SPI_Address, message_type, 0, 0, 0, 0]
        for b in range(self.I2CInBytes[port_index]):
            outArray.append(0)
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA and len(reply) - 6 == self.I2CInBytes[port_index]):
                values = []
                for b in range(6, len(reply)):
                    values.append(reply[b])
                return values
            else:
                raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                return
        else:
            raise IOError(&#34;get_sensor error: No SPI response&#34;)
            return

    elif(self.SensorType[port_index] == self.SENSOR_TYPE.TOUCH
      or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_TOUCH
      or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_TOUCH
      or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_ULTRASONIC
      or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_REFLECTED
      or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_AMBIENT
      or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_COLOR
      or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_LISTEN
      or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_INFRARED_PROXIMITY):
        outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            if((reply[4] == self.SensorType[port_index] or (self.SensorType[port_index] == self.SENSOR_TYPE.TOUCH and (reply[4] == self.SENSOR_TYPE.NXT_TOUCH or reply[4] == self.SENSOR_TYPE.EV3_TOUCH))) and reply[5] == self.SENSOR_STATE.VALID_DATA):
                return reply[6]
            else:
                raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                return
        else:
            raise IOError(&#34;get_sensor error: No SPI response&#34;)
            return

    elif self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_FULL:
        outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                return [reply[6], ((reply[7] &lt;&lt; 2) | ((reply[11] &gt;&gt; 6) &amp; 0x03)), ((reply[8] &lt;&lt; 2) | ((reply[11] &gt;&gt; 4) &amp; 0x03)), ((reply[9] &lt;&lt; 2) | ((reply[11] &gt;&gt; 2) &amp; 0x03)), ((reply[10] &lt;&lt; 2) | (reply[11] &amp; 0x03))]
            else:
                raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                return
        else:
            raise IOError(&#34;get_sensor error: No SPI response&#34;)
            return

    elif(self.SensorType[port_index] == self.SENSOR_TYPE.NXT_LIGHT_ON
      or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_LIGHT_OFF
      or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_RED
      or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_GREEN
      or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_BLUE
      or self.SensorType[port_index] == self.SENSOR_TYPE.NXT_COLOR_OFF
      or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_ABS
      or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_DPS
      or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_CM
      or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_INCHES):
        outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                value = int((reply[6] &lt;&lt; 8) | reply[7])
                if((self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_ABS
                or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_DPS)
                and (value &amp; 0x8000)):
                    value = value - 0x10000
                elif(self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_CM
                  or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_ULTRASONIC_INCHES):
                    value = value / 10
                return value
            else:
                raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                return
        else:
            raise IOError(&#34;get_sensor error: No SPI response&#34;)
            return

    elif(self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_RAW_REFLECTED
      or self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_ABS_DPS):
        outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                results = [int((reply[6] &lt;&lt; 8) | reply[7]), int((reply[8] &lt;&lt; 8) | reply[9])]
                if self.SensorType[port_index] == self.SENSOR_TYPE.EV3_GYRO_ABS_DPS:
                    for r in range(len(results)):
                        if results[r] &gt;= 0x8000:
                            results[r] = results[r] - 0x10000
                return results
            else:
                raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                return
        else:
            raise IOError(&#34;get_sensor error: No SPI response&#34;)
            return

    elif(self.SensorType[port_index] == self.SENSOR_TYPE.EV3_COLOR_COLOR_COMPONENTS):
        outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                return [int((reply[6] &lt;&lt; 8) | reply[7]), int((reply[8] &lt;&lt; 8) | reply[9]), int((reply[10] &lt;&lt; 8) | reply[11]), int((reply[12] &lt;&lt; 8) | reply[13])]
            else:
                raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                return
        else:
            raise IOError(&#34;get_sensor error: No SPI response&#34;)
            return

    elif(self.SensorType[port_index] == self.SENSOR_TYPE.EV3_INFRARED_SEEK):
        outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                results = [[int(reply[6]), int(reply[7])], [int(reply[8]), int(reply[9])], [int(reply[10]), int(reply[11])], [int(reply[12]), int(reply[13])]]
                for c in range(len(results)):
                    for v in range(len(results[c])):
                        if results[c][v] &gt;= 0x80:
                            results[c][v] = results[c][v] - 0x100
                return results
            else:
                raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                return
        else:
            raise IOError(&#34;get_sensor error: No SPI response&#34;)
            return

    elif(self.SensorType[port_index] == self.SENSOR_TYPE.EV3_INFRARED_REMOTE):
        outArray = [self.SPI_Address, message_type, 0, 0, 0, 0, 0, 0, 0, 0]
        reply = self.spi_transfer_array(outArray)
        if(reply[3] == 0xA5):
            if(reply[4] == self.SensorType[port_index] and reply[5] == self.SENSOR_STATE.VALID_DATA):
                results = [0, 0, 0, 0]
                for r in range(len(results)):
                    value = int(reply[6 + r])
                    if value == 1:
                        results[r] = [1, 0, 0, 0, 0]
                    elif value == 2:
                        results[r] = [0, 1, 0, 0, 0]
                    elif value == 3:
                        results[r] = [0, 0, 1, 0, 0]
                    elif value == 4:
                        results[r] = [0, 0, 0, 1, 0]
                    elif value == 5:
                        results[r] = [1, 0, 1, 0, 0]
                    elif value == 6:
                        results[r] = [1, 0, 0, 1, 0]
                    elif value == 7:
                        results[r] = [0, 1, 1, 0, 0]
                    elif value == 8:
                        results[r] = [0, 1, 0, 1, 0]
                    elif value == 9:
                        results[r] = [0, 0, 0, 0, 1]
                    elif value == 10:
                        results[r] = [1, 1, 0, 0, 0]
                    elif value == 11:
                        results[r] = [0, 0, 1, 1, 0]
                    else:
                        results[r] = [0, 0, 0, 0, 0]
                return results
            else:
                raise SensorError(&#34;get_sensor error: Invalid sensor data&#34;)
                return
        else:
            raise IOError(&#34;get_sensor error: No SPI response&#34;)
            return

    raise IOError(&#34;get_sensor error: Sensor not configured or not supported.&#34;)
    return # sensor not configured or not supported.</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.get_version_firmware"><code class="name flex">
<span>def <span class="ident">get_version_firmware</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the firmware version</p>
<p>Returns:
firmware version</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_version_firmware(self):
    &#34;&#34;&#34;
    Read the firmware version

    Returns:
    firmware version
    &#34;&#34;&#34;
    version = self.spi_read_32(self.BPSPI_MESSAGE_TYPE.GET_FIRMWARE_VERSION)
    return (&#34;%d.%d.%d&#34; % ((version / 1000000), ((version / 1000) % 1000), (version % 1000)))</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.get_version_hardware"><code class="name flex">
<span>def <span class="ident">get_version_hardware</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the hardware version</p>
<p>Returns:
hardware version</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_version_hardware(self):
    &#34;&#34;&#34;
    Read the hardware version

    Returns:
    hardware version
    &#34;&#34;&#34;
    version = self.spi_read_32(self.BPSPI_MESSAGE_TYPE.GET_HARDWARE_VERSION)
    return (&#34;%d.%d.%d&#34; % ((version / 1000000), ((version / 1000) % 1000), (version % 1000)))</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.get_voltage_3v3"><code class="name flex">
<span>def <span class="ident">get_voltage_3v3</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the 3.3v circuit voltage</p>
<p>Returns:
3.3v circuit voltage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_3v3(self):
    &#34;&#34;&#34;
    Get the 3.3v circuit voltage

    Returns:
    3.3v circuit voltage
    &#34;&#34;&#34;
    value = self.spi_read_16(self.BPSPI_MESSAGE_TYPE.GET_VOLTAGE_3V3)
    return (value / 1000.0)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.get_voltage_5v"><code class="name flex">
<span>def <span class="ident">get_voltage_5v</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the 5v circuit voltage</p>
<p>Returns:
5v circuit voltage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_5v(self):
    &#34;&#34;&#34;
    Get the 5v circuit voltage

    Returns:
    5v circuit voltage
    &#34;&#34;&#34;
    value = self.spi_read_16(self.BPSPI_MESSAGE_TYPE.GET_VOLTAGE_5V)
    return (value / 1000.0)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.get_voltage_9v"><code class="name flex">
<span>def <span class="ident">get_voltage_9v</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the 9v circuit voltage</p>
<p>Returns:
9v circuit voltage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_9v(self):
    &#34;&#34;&#34;
    Get the 9v circuit voltage

    Returns:
    9v circuit voltage
    &#34;&#34;&#34;
    value = self.spi_read_16(self.BPSPI_MESSAGE_TYPE.GET_VOLTAGE_9V)
    return (value / 1000.0)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.get_voltage_battery"><code class="name flex">
<span>def <span class="ident">get_voltage_battery</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the battery voltage</p>
<p>Returns:
battery voltage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_battery(self):
    &#34;&#34;&#34;
    Get the battery voltage

    Returns:
    battery voltage
    &#34;&#34;&#34;
    value = self.spi_read_16(self.BPSPI_MESSAGE_TYPE.GET_VOLTAGE_VCC)
    return (value / 1000.0)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.offset_motor_encoder"><code class="name flex">
<span>def <span class="ident">offset_motor_encoder</span></span>(<span>self, port, position)</span>
</code></dt>
<dd>
<div class="desc"><p>Offset a motor encoder</p>
<p>Keyword arguments:
port &ndash; The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
offset &ndash; The encoder offset</p>
<p>You can zero the encoder by offsetting it by the current position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def offset_motor_encoder(self, port, position):
    &#34;&#34;&#34;
    Offset a motor encoder

    Keyword arguments:
    port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
    offset -- The encoder offset

    You can zero the encoder by offsetting it by the current position
    &#34;&#34;&#34;
    position = int(position)
    outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.OFFSET_MOTOR_ENCODER, int(port), ((position &gt;&gt; 24) &amp; 0xFF), ((position &gt;&gt; 16) &amp; 0xFF), ((position &gt;&gt; 8) &amp; 0xFF), (position &amp; 0xFF)]
    self.spi_transfer_array(outArray)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.reset_all"><code class="name flex">
<span>def <span class="ident">reset_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the BrickPi. Set all the sensors' type to NONE, set the motors to float, and motors' limits and constants to default, and return control of the LED to the firmware.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_all(self):
    &#34;&#34;&#34;
    Reset the BrickPi. Set all the sensors&#39; type to NONE, set the motors to float, and motors&#39; limits and constants to default, and return control of the LED to the firmware.
    &#34;&#34;&#34;
    # reset all sensors
    self.set_sensor_type(self.PORT_1 + self.PORT_2 + self.PORT_3 + self.PORT_4, self.SENSOR_TYPE.NONE)

    # turn off all motors
    self.set_motor_power(self.PORT_A + self.PORT_B + self.PORT_C + self.PORT_D, self.MOTOR_FLOAT)

    # reset motor limits
    self.set_motor_limits(self.PORT_A + self.PORT_B + self.PORT_C + self.PORT_D)

    # reset motor kP and kD constants
    self.set_motor_position_kp(self.PORT_A + self.PORT_B + self.PORT_C + self.PORT_D)
    self.set_motor_position_kd(self.PORT_A + self.PORT_B + self.PORT_C + self.PORT_D)

    # return the LED to the control of the FW
    self.set_led(-1)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.reset_motor_encoder"><code class="name flex">
<span>def <span class="ident">reset_motor_encoder</span></span>(<span>self, port)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset motor encoder(s) to 0</p>
<p>Keyword arguments:
port &ndash; The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_motor_encoder(self, port):
    &#34;&#34;&#34;
    Reset motor encoder(s) to 0

    Keyword arguments:
    port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
    &#34;&#34;&#34;
    if port &amp; self.PORT_A:
        self.offset_motor_encoder(self.PORT_A, self.get_motor_encoder(self.PORT_A))

    if port &amp; self.PORT_B:
        self.offset_motor_encoder(self.PORT_B, self.get_motor_encoder(self.PORT_B))

    if port &amp; self.PORT_C:
        self.offset_motor_encoder(self.PORT_C, self.get_motor_encoder(self.PORT_C))

    if port &amp; self.PORT_D:
        self.offset_motor_encoder(self.PORT_D, self.get_motor_encoder(self.PORT_D))</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.set_led"><code class="name flex">
<span>def <span class="ident">set_led</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Control the onboard LED</p>
<p>Keyword arguments:
value &ndash; the value (in percent) to set the LED brightness to. -1 returns control of the LED to the firmware.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_led(self, value):
    &#34;&#34;&#34;
    Control the onboard LED

    Keyword arguments:
    value -- the value (in percent) to set the LED brightness to. -1 returns control of the LED to the firmware.
    &#34;&#34;&#34;
    self.spi_write_8(self.BPSPI_MESSAGE_TYPE.SET_LED, value)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.set_motor_dps"><code class="name flex">
<span>def <span class="ident">set_motor_dps</span></span>(<span>self, port, dps)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the motor target speed in degrees per second</p>
<p>Keyword arguments:
port &ndash; The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
dps &ndash; The target speed in degrees per second</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_motor_dps(self, port, dps):
    &#34;&#34;&#34;
    Set the motor target speed in degrees per second

    Keyword arguments:
    port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
    dps -- The target speed in degrees per second
    &#34;&#34;&#34;
    dps = int(dps)
    outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_DPS, int(port), ((dps &gt;&gt; 8) &amp; 0xFF), (dps &amp; 0xFF)]
    self.spi_transfer_array(outArray)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.set_motor_limits"><code class="name flex">
<span>def <span class="ident">set_motor_limits</span></span>(<span>self, port, power=0, dps=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the motor speed limit</p>
<p>Keyword arguments:
port &ndash; The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
power &ndash; The power limit in percent (0 to 100), with 0 being no limit (100)
dps &ndash; The speed limit in degrees per second, with 0 being no limit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_motor_limits(self, port, power = 0, dps = 0):
    &#34;&#34;&#34;
    Set the motor speed limit

    Keyword arguments:
    port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
    power -- The power limit in percent (0 to 100), with 0 being no limit (100)
    dps -- The speed limit in degrees per second, with 0 being no limit
    &#34;&#34;&#34;
    dps = int(dps)
    outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_LIMITS, int(port), int(power), ((dps &gt;&gt; 8) &amp; 0xFF), (dps &amp; 0xFF)]
    self.spi_transfer_array(outArray)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.set_motor_position"><code class="name flex">
<span>def <span class="ident">set_motor_position</span></span>(<span>self, port, position)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the motor target position in degrees</p>
<p>Keyword arguments:
port &ndash; The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
position &ndash; The target position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_motor_position(self, port, position):
    &#34;&#34;&#34;
    Set the motor target position in degrees

    Keyword arguments:
    port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
    position -- The target position
    &#34;&#34;&#34;
    position = int(position)
    outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_POSITION, int(port), ((position &gt;&gt; 24) &amp; 0xFF), ((position &gt;&gt; 16) &amp; 0xFF), ((position &gt;&gt; 8) &amp; 0xFF), (position &amp; 0xFF)]
    self.spi_transfer_array(outArray)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.set_motor_position_kd"><code class="name flex">
<span>def <span class="ident">set_motor_position_kd</span></span>(<span>self, port, kd=70)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the motor target position KD constant</p>
<p>If you set kp higher, the motor will be more responsive to errors in position, at the cost of perhaps overshooting and oscillating.
kd slows down the motor as it approaches the target, and helps to prevent overshoot.
In general, if you increase kp, you should also increase kd to keep the motor from overshooting and oscillating.</p>
<p>Keyword arguments:
port &ndash; The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
kd &ndash; The KD constant (default 70)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_motor_position_kd(self, port, kd = 70):
    &#34;&#34;&#34;
    Set the motor target position KD constant

    If you set kp higher, the motor will be more responsive to errors in position, at the cost of perhaps overshooting and oscillating.
    kd slows down the motor as it approaches the target, and helps to prevent overshoot.
    In general, if you increase kp, you should also increase kd to keep the motor from overshooting and oscillating.

    Keyword arguments:
    port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
    kd -- The KD constant (default 70)
    &#34;&#34;&#34;
    outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_POSITION_KD, int(port), int(kd)]
    self.spi_transfer_array(outArray)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.set_motor_position_kp"><code class="name flex">
<span>def <span class="ident">set_motor_position_kp</span></span>(<span>self, port, kp=25)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the motor target position KP constant</p>
<p>If you set kp higher, the motor will be more responsive to errors in position, at the cost of perhaps overshooting and oscillating.
kd slows down the motor as it approaches the target, and helps to prevent overshoot.
In general, if you increase kp, you should also increase kd to keep the motor from overshooting and oscillating.</p>
<p>Keyword arguments:
port &ndash; The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
kp &ndash; The KP constant (default 25)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_motor_position_kp(self, port, kp = 25):
    &#34;&#34;&#34;
    Set the motor target position KP constant

    If you set kp higher, the motor will be more responsive to errors in position, at the cost of perhaps overshooting and oscillating.
    kd slows down the motor as it approaches the target, and helps to prevent overshoot.
    In general, if you increase kp, you should also increase kd to keep the motor from overshooting and oscillating.

    Keyword arguments:
    port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
    kp -- The KP constant (default 25)
    &#34;&#34;&#34;
    outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_POSITION_KP, int(port), int(kp)]
    self.spi_transfer_array(outArray)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.set_motor_position_relative"><code class="name flex">
<span>def <span class="ident">set_motor_position_relative</span></span>(<span>self, port, degrees)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the relative motor target position in degrees. Current position plus the specified degrees.</p>
<p>Keyword arguments:
port &ndash; The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
degrees &ndash; The relative target position in degrees</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_motor_position_relative(self, port, degrees):
    &#34;&#34;&#34;
    Set the relative motor target position in degrees. Current position plus the specified degrees.

    Keyword arguments:
    port -- The motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
    degrees -- The relative target position in degrees
    &#34;&#34;&#34;
    for p in range(4):
        if port &amp; (1 &lt;&lt; p):
            self.set_motor_position((1 &lt;&lt; p), (self.get_motor_encoder(1 &lt;&lt; p) + degrees))</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.set_motor_power"><code class="name flex">
<span>def <span class="ident">set_motor_power</span></span>(<span>self, port, power)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the motor power in percent</p>
<p>Keyword arguments:
port &ndash; The Motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
power &ndash; The power from -100 to 100, or -128 for float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_motor_power(self, port, power):
    &#34;&#34;&#34;
    Set the motor power in percent

    Keyword arguments:
    port -- The Motor port(s). PORT_A, PORT_B, PORT_C, and/or PORT_D.
    power -- The power from -100 to 100, or -128 for float
    &#34;&#34;&#34;
    outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_MOTOR_POWER, int(port), int(power)]
    self.spi_transfer_array(outArray)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.set_sensor_type"><code class="name flex">
<span>def <span class="ident">set_sensor_type</span></span>(<span>self, port, type, params=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the sensor type</p>
<p>Keyword arguments:
port &ndash; The sensor port(s). PORT_1, PORT_2, PORT_3, and/or PORT_4.
type &ndash; The sensor type
params = 0 &ndash; the parameters needed for some sensor types.</p>
<p>params is used for the following sensor types:
CUSTOM &ndash; a 16-bit integer used to configure the hardware.
I2C &ndash; a list of settings:
params[0] &ndash; Settings/flags
params[1] &ndash; target Speed in microseconds (0-255). Realistically the speed will vary.
if SENSOR_I2C_SETTINGS_SAME flag set in I2C Settings:
params[2] &ndash; Delay in microseconds between transactions.
params[3] &ndash; Address
params[4] &ndash; List of bytes to write
params[5] &ndash; Number of bytes to read</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_sensor_type(self, port, type, params = 0):
    &#34;&#34;&#34;
    Set the sensor type

    Keyword arguments:
    port -- The sensor port(s). PORT_1, PORT_2, PORT_3, and/or PORT_4.
    type -- The sensor type
    params = 0 -- the parameters needed for some sensor types.

    params is used for the following sensor types:
        CUSTOM -- a 16-bit integer used to configure the hardware.
        I2C -- a list of settings:
            params[0] -- Settings/flags
            params[1] -- target Speed in microseconds (0-255). Realistically the speed will vary.
            if SENSOR_I2C_SETTINGS_SAME flag set in I2C Settings:
                params[2] -- Delay in microseconds between transactions.
                params[3] -- Address
                params[4] -- List of bytes to write
                params[5] -- Number of bytes to read
    &#34;&#34;&#34;
    for p in range(4):
        if port &amp; (1 &lt;&lt; p):
            self.SensorType[p] = type
    if(type == self.SENSOR_TYPE.CUSTOM):
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_SENSOR_TYPE, int(port), type, ((params[0] &gt;&gt; 8) &amp; 0xFF), (params[0] &amp; 0xFF)]

        #self.spi_write_24(self.BPSPI_MESSAGE_TYPE.SET_SENSOR_TYPE, int(port), ((type &lt;&lt; 16) + (params[0])))
    elif(type == self.SENSOR_TYPE.I2C):
        if len(params) &gt;= 2:
            outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_SENSOR_TYPE, int(port), type, params[0], params[1]] # Settings, SpeedUS
            if params[0] &amp; self.SENSOR_I2C_SETTINGS.SAME and len(params) &gt;= 6:
                outArray.append((params[2] &gt;&gt; 24) &amp; 0xFF) # DelayUS
                outArray.append((params[2] &gt;&gt; 16) &amp; 0xFF) #   &#39;&#39;
                outArray.append((params[2] &gt;&gt; 8) &amp; 0xFF)  #   &#39;&#39;
                outArray.append(params[2] &amp; 0xFF)         #   &#39;&#39;
                outArray.append(params[3] &amp; 0xFF)   # Address
                outArray.append(params[5] &amp; 0xFF)   # InBytes
                for p in range(4):
                    if port &amp; (1 &lt;&lt; p):
                        self.I2CInBytes[p] = params[5] &amp; 0xFF
                outArray.append(len(params[4]))     # OutBytes
                outArray.extend(params[4])          # OutArray
    else:
        outArray = [self.SPI_Address, self.BPSPI_MESSAGE_TYPE.SET_SENSOR_TYPE, int(port), type]

    self.spi_transfer_array(outArray)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.spi_read_16"><code class="name flex">
<span>def <span class="ident">spi_read_16</span></span>(<span>self, MessageType)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a 16-bit value over SPI</p>
<p>Keyword arguments:
MessageType &ndash; the SPI message type</p>
<p>Returns:
value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spi_read_16(self, MessageType):
    &#34;&#34;&#34;
    Read a 16-bit value over SPI

    Keyword arguments:
    MessageType -- the SPI message type

    Returns:
    value
    &#34;&#34;&#34;
    outArray = [self.SPI_Address, MessageType, 0, 0, 0, 0]
    reply = self.spi_transfer_array(outArray)
    if(reply[3] == 0xA5):
        return int((reply[4] &lt;&lt; 8) | reply[5])
    raise IOError(&#34;No SPI response&#34;)
    return</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.spi_read_32"><code class="name flex">
<span>def <span class="ident">spi_read_32</span></span>(<span>self, MessageType)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a 32-bit value over SPI</p>
<p>Keyword arguments:
MessageType &ndash; the SPI message type</p>
<p>Returns :
value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spi_read_32(self, MessageType):
    &#34;&#34;&#34;
    Read a 32-bit value over SPI

    Keyword arguments:
    MessageType -- the SPI message type

    Returns :
    value
    &#34;&#34;&#34;
    outArray = [self.SPI_Address, MessageType, 0, 0, 0, 0, 0, 0]
    reply = self.spi_transfer_array(outArray)
    if(reply[3] == 0xA5):
        return int((reply[4] &lt;&lt; 24) | (reply[5] &lt;&lt; 16) | (reply[6] &lt;&lt; 8) | reply[7])
    raise IOError(&#34;No SPI response&#34;)
    return</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.spi_transfer_array"><code class="name flex">
<span>def <span class="ident">spi_transfer_array</span></span>(<span>self, data_out)</span>
</code></dt>
<dd>
<div class="desc"><p>Conduct a SPI transaction</p>
<p>Keyword arguments:
data_out &ndash; a list of bytes to send. The length of the list will determine how many bytes are transferred.</p>
<p>Returns a list of the bytes read.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spi_transfer_array(self, data_out):
    &#34;&#34;&#34;
    Conduct a SPI transaction

    Keyword arguments:
    data_out -- a list of bytes to send. The length of the list will determine how many bytes are transferred.

    Returns a list of the bytes read.
    &#34;&#34;&#34;
    return BP_SPI.xfer2(data_out)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.spi_write_16"><code class="name flex">
<span>def <span class="ident">spi_write_16</span></span>(<span>self, MessageType, Value)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a 16-bit value over SPI</p>
<p>Keyword arguments:
MessageType &ndash; the SPI message type
Value &ndash; the value to be sent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spi_write_16(self, MessageType, Value):
    &#34;&#34;&#34;
    Send a 16-bit value over SPI

    Keyword arguments:
    MessageType -- the SPI message type
    Value -- the value to be sent
    &#34;&#34;&#34;
    outArray = [self.SPI_Address, MessageType, ((Value &gt;&gt; 8) &amp; 0xFF), (Value &amp; 0xFF)]
    self.spi_transfer_array(outArray)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.spi_write_24"><code class="name flex">
<span>def <span class="ident">spi_write_24</span></span>(<span>self, MessageType, Value)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a 24-bit value over SPI</p>
<p>Keyword arguments:
MessageType &ndash; the SPI message type
Value &ndash; the value to be sent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spi_write_24(self, MessageType, Value):
    &#34;&#34;&#34;
    Send a 24-bit value over SPI

    Keyword arguments:
    MessageType -- the SPI message type
    Value -- the value to be sent
    &#34;&#34;&#34;
    outArray = [self.SPI_Address, MessageType, ((Value &gt;&gt; 16) &amp; 0xFF), ((Value &gt;&gt; 8) &amp; 0xFF), (Value &amp; 0xFF)]
    self.spi_transfer_array(outArray)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.spi_write_32"><code class="name flex">
<span>def <span class="ident">spi_write_32</span></span>(<span>self, MessageType, Value)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a 32-bit value over SPI</p>
<p>Keyword arguments:
MessageType &ndash; the SPI message type
Value &ndash; the value to be sent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spi_write_32(self, MessageType, Value):
    &#34;&#34;&#34;
    Send a 32-bit value over SPI

    Keyword arguments:
    MessageType -- the SPI message type
    Value -- the value to be sent
    &#34;&#34;&#34;
    outArray = [self.SPI_Address, MessageType, ((Value &gt;&gt; 24) &amp; 0xFF), ((Value &gt;&gt; 16) &amp; 0xFF), ((Value &gt;&gt; 8) &amp; 0xFF), (Value &amp; 0xFF)]
    self.spi_transfer_array(outArray)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.spi_write_8"><code class="name flex">
<span>def <span class="ident">spi_write_8</span></span>(<span>self, MessageType, Value)</span>
</code></dt>
<dd>
<div class="desc"><p>Send an 8-bit value over SPI</p>
<p>Keyword arguments:
MessageType &ndash; the SPI message type
Value &ndash; the value to be sent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spi_write_8(self, MessageType, Value):
    &#34;&#34;&#34;
    Send an 8-bit value over SPI

    Keyword arguments:
    MessageType -- the SPI message type
    Value -- the value to be sent
    &#34;&#34;&#34;
    outArray = [self.SPI_Address, MessageType, (Value &amp; 0xFF)]
    self.spi_transfer_array(outArray)</code></pre>
</details>
</dd>
<dt id="brickpi3.BrickPi3.transact_i2c"><code class="name flex">
<span>def <span class="ident">transact_i2c</span></span>(<span>self, port, Address, OutArray, InBytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Conduct an I2C transaction</p>
<p>Keyword arguments:
port &ndash; The sensor port (one at a time). PORT_1, PORT_2, PORT_3, or PORT_4.
Address &ndash; The I2C address for the device. Bits 1-7, not 0-6.
OutArray &ndash; A list of bytes to write to the device
InBytes &ndash; The number of bytes to read from the device</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transact_i2c(self, port, Address, OutArray, InBytes):
    &#34;&#34;&#34;
    Conduct an I2C transaction

    Keyword arguments:
    port -- The sensor port (one at a time). PORT_1, PORT_2, PORT_3, or PORT_4.
    Address -- The I2C address for the device. Bits 1-7, not 0-6.
    OutArray -- A list of bytes to write to the device
    InBytes -- The number of bytes to read from the device
    &#34;&#34;&#34;
    if port == self.PORT_1:
        message_type = self.BPSPI_MESSAGE_TYPE.I2C_TRANSACT_1
        port_index = 0
    elif port == self.PORT_2:
        message_type = self.BPSPI_MESSAGE_TYPE.I2C_TRANSACT_2
        port_index = 1
    elif port == self.PORT_3:
        message_type = self.BPSPI_MESSAGE_TYPE.I2C_TRANSACT_3
        port_index = 2
    elif port == self.PORT_4:
        message_type = self.BPSPI_MESSAGE_TYPE.I2C_TRANSACT_4
        port_index = 3
    else:
        raise IOError(&#34;transact_i2c error. Must be one sensor port at a time. PORT_1, PORT_2, PORT_3, or PORT_4.&#34;)
        return

    if self.SensorType[port_index] != self.SENSOR_TYPE.I2C:
        return
    outArray = [self.SPI_Address, message_type, Address, InBytes]
    self.I2CInBytes[port_index] = InBytes
    OutBytes = len(OutArray)
    if(OutBytes &gt; self.I2C_LENGTH_LIMIT):
        outArray.append(self.I2C_LENGTH_LIMIT)
        for b in range(self.I2C_LENGTH_LIMIT):
            outArray.append(OutArray[b])
    else:
        outArray.append(OutBytes)
        outArray.extend(OutArray)
    self.spi_transfer_array(outArray)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="brickpi3.Enumeration"><code class="flex name class">
<span>class <span class="ident">Enumeration</span></span>
<span>(</span><span>names)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Enumeration(object):
    def __init__(self, names):  # or *names, with no .split()
        number = 0
        for line, name in enumerate(names.split(&#39;\n&#39;)):
            if name.find(&#34;,&#34;) &gt;= 0:
                # strip out the spaces
                while(name.find(&#34; &#34;) != -1):
                    name = name[:name.find(&#34; &#34;)] + name[(name.find(&#34; &#34;) + 1):]

                # strip out the commas
                while(name.find(&#34;,&#34;) != -1):
                    name = name[:name.find(&#34;,&#34;)] + name[(name.find(&#34;,&#34;) + 1):]

                # if the value was specified
                if(name.find(&#34;=&#34;) != -1):
                    number = int(float(name[(name.find(&#34;=&#34;) + 1):]))
                    name = name[:name.find(&#34;=&#34;)]

                # optionally print to confirm that it&#39;s working correctly
                #print &#34;%40s has a value of %d&#34; % (name, number)

                setattr(self, name, number)
                number = number + 1</code></pre>
</details>
</dd>
<dt id="brickpi3.FirmwareVersionError"><code class="flex name class">
<span>class <span class="ident">FirmwareVersionError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Exception raised if the BrickPi3 firmware needs to be updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FirmwareVersionError(Exception):
    &#34;&#34;&#34;Exception raised if the BrickPi3 firmware needs to be updated&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="brickpi3.SensorError"><code class="flex name class">
<span>class <span class="ident">SensorError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Exception raised if a sensor is not yet configured when trying to read it with get_sensor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SensorError(Exception):
    &#34;&#34;&#34;Exception raised if a sensor is not yet configured when trying to read it with get_sensor&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="brickpi3.set_address" href="#brickpi3.set_address">set_address</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="brickpi3.BrickPi3" href="#brickpi3.BrickPi3">BrickPi3</a></code></h4>
<ul class="">
<li><code><a title="brickpi3.BrickPi3.BPSPI_MESSAGE_TYPE" href="#brickpi3.BrickPi3.BPSPI_MESSAGE_TYPE">BPSPI_MESSAGE_TYPE</a></code></li>
<li><code><a title="brickpi3.BrickPi3.I2CInBytes" href="#brickpi3.BrickPi3.I2CInBytes">I2CInBytes</a></code></li>
<li><code><a title="brickpi3.BrickPi3.I2C_LENGTH_LIMIT" href="#brickpi3.BrickPi3.I2C_LENGTH_LIMIT">I2C_LENGTH_LIMIT</a></code></li>
<li><code><a title="brickpi3.BrickPi3.MOTOR_FLOAT" href="#brickpi3.BrickPi3.MOTOR_FLOAT">MOTOR_FLOAT</a></code></li>
<li><code><a title="brickpi3.BrickPi3.MOTOR_STATUS_FLAG" href="#brickpi3.BrickPi3.MOTOR_STATUS_FLAG">MOTOR_STATUS_FLAG</a></code></li>
<li><code><a title="brickpi3.BrickPi3.PORT_1" href="#brickpi3.BrickPi3.PORT_1">PORT_1</a></code></li>
<li><code><a title="brickpi3.BrickPi3.PORT_2" href="#brickpi3.BrickPi3.PORT_2">PORT_2</a></code></li>
<li><code><a title="brickpi3.BrickPi3.PORT_3" href="#brickpi3.BrickPi3.PORT_3">PORT_3</a></code></li>
<li><code><a title="brickpi3.BrickPi3.PORT_4" href="#brickpi3.BrickPi3.PORT_4">PORT_4</a></code></li>
<li><code><a title="brickpi3.BrickPi3.PORT_A" href="#brickpi3.BrickPi3.PORT_A">PORT_A</a></code></li>
<li><code><a title="brickpi3.BrickPi3.PORT_B" href="#brickpi3.BrickPi3.PORT_B">PORT_B</a></code></li>
<li><code><a title="brickpi3.BrickPi3.PORT_C" href="#brickpi3.BrickPi3.PORT_C">PORT_C</a></code></li>
<li><code><a title="brickpi3.BrickPi3.PORT_D" href="#brickpi3.BrickPi3.PORT_D">PORT_D</a></code></li>
<li><code><a title="brickpi3.BrickPi3.SENSOR_CUSTOM" href="#brickpi3.BrickPi3.SENSOR_CUSTOM">SENSOR_CUSTOM</a></code></li>
<li><code><a title="brickpi3.BrickPi3.SENSOR_I2C_SETTINGS" href="#brickpi3.BrickPi3.SENSOR_I2C_SETTINGS">SENSOR_I2C_SETTINGS</a></code></li>
<li><code><a title="brickpi3.BrickPi3.SENSOR_STATE" href="#brickpi3.BrickPi3.SENSOR_STATE">SENSOR_STATE</a></code></li>
<li><code><a title="brickpi3.BrickPi3.SENSOR_TYPE" href="#brickpi3.BrickPi3.SENSOR_TYPE">SENSOR_TYPE</a></code></li>
<li><code><a title="brickpi3.BrickPi3.SensorType" href="#brickpi3.BrickPi3.SensorType">SensorType</a></code></li>
<li><code><a title="brickpi3.BrickPi3.get_board" href="#brickpi3.BrickPi3.get_board">get_board</a></code></li>
<li><code><a title="brickpi3.BrickPi3.get_id" href="#brickpi3.BrickPi3.get_id">get_id</a></code></li>
<li><code><a title="brickpi3.BrickPi3.get_manufacturer" href="#brickpi3.BrickPi3.get_manufacturer">get_manufacturer</a></code></li>
<li><code><a title="brickpi3.BrickPi3.get_motor_encoder" href="#brickpi3.BrickPi3.get_motor_encoder">get_motor_encoder</a></code></li>
<li><code><a title="brickpi3.BrickPi3.get_motor_status" href="#brickpi3.BrickPi3.get_motor_status">get_motor_status</a></code></li>
<li><code><a title="brickpi3.BrickPi3.get_sensor" href="#brickpi3.BrickPi3.get_sensor">get_sensor</a></code></li>
<li><code><a title="brickpi3.BrickPi3.get_version_firmware" href="#brickpi3.BrickPi3.get_version_firmware">get_version_firmware</a></code></li>
<li><code><a title="brickpi3.BrickPi3.get_version_hardware" href="#brickpi3.BrickPi3.get_version_hardware">get_version_hardware</a></code></li>
<li><code><a title="brickpi3.BrickPi3.get_voltage_3v3" href="#brickpi3.BrickPi3.get_voltage_3v3">get_voltage_3v3</a></code></li>
<li><code><a title="brickpi3.BrickPi3.get_voltage_5v" href="#brickpi3.BrickPi3.get_voltage_5v">get_voltage_5v</a></code></li>
<li><code><a title="brickpi3.BrickPi3.get_voltage_9v" href="#brickpi3.BrickPi3.get_voltage_9v">get_voltage_9v</a></code></li>
<li><code><a title="brickpi3.BrickPi3.get_voltage_battery" href="#brickpi3.BrickPi3.get_voltage_battery">get_voltage_battery</a></code></li>
<li><code><a title="brickpi3.BrickPi3.offset_motor_encoder" href="#brickpi3.BrickPi3.offset_motor_encoder">offset_motor_encoder</a></code></li>
<li><code><a title="brickpi3.BrickPi3.reset_all" href="#brickpi3.BrickPi3.reset_all">reset_all</a></code></li>
<li><code><a title="brickpi3.BrickPi3.reset_motor_encoder" href="#brickpi3.BrickPi3.reset_motor_encoder">reset_motor_encoder</a></code></li>
<li><code><a title="brickpi3.BrickPi3.set_led" href="#brickpi3.BrickPi3.set_led">set_led</a></code></li>
<li><code><a title="brickpi3.BrickPi3.set_motor_dps" href="#brickpi3.BrickPi3.set_motor_dps">set_motor_dps</a></code></li>
<li><code><a title="brickpi3.BrickPi3.set_motor_limits" href="#brickpi3.BrickPi3.set_motor_limits">set_motor_limits</a></code></li>
<li><code><a title="brickpi3.BrickPi3.set_motor_position" href="#brickpi3.BrickPi3.set_motor_position">set_motor_position</a></code></li>
<li><code><a title="brickpi3.BrickPi3.set_motor_position_kd" href="#brickpi3.BrickPi3.set_motor_position_kd">set_motor_position_kd</a></code></li>
<li><code><a title="brickpi3.BrickPi3.set_motor_position_kp" href="#brickpi3.BrickPi3.set_motor_position_kp">set_motor_position_kp</a></code></li>
<li><code><a title="brickpi3.BrickPi3.set_motor_position_relative" href="#brickpi3.BrickPi3.set_motor_position_relative">set_motor_position_relative</a></code></li>
<li><code><a title="brickpi3.BrickPi3.set_motor_power" href="#brickpi3.BrickPi3.set_motor_power">set_motor_power</a></code></li>
<li><code><a title="brickpi3.BrickPi3.set_sensor_type" href="#brickpi3.BrickPi3.set_sensor_type">set_sensor_type</a></code></li>
<li><code><a title="brickpi3.BrickPi3.spi_read_16" href="#brickpi3.BrickPi3.spi_read_16">spi_read_16</a></code></li>
<li><code><a title="brickpi3.BrickPi3.spi_read_32" href="#brickpi3.BrickPi3.spi_read_32">spi_read_32</a></code></li>
<li><code><a title="brickpi3.BrickPi3.spi_transfer_array" href="#brickpi3.BrickPi3.spi_transfer_array">spi_transfer_array</a></code></li>
<li><code><a title="brickpi3.BrickPi3.spi_write_16" href="#brickpi3.BrickPi3.spi_write_16">spi_write_16</a></code></li>
<li><code><a title="brickpi3.BrickPi3.spi_write_24" href="#brickpi3.BrickPi3.spi_write_24">spi_write_24</a></code></li>
<li><code><a title="brickpi3.BrickPi3.spi_write_32" href="#brickpi3.BrickPi3.spi_write_32">spi_write_32</a></code></li>
<li><code><a title="brickpi3.BrickPi3.spi_write_8" href="#brickpi3.BrickPi3.spi_write_8">spi_write_8</a></code></li>
<li><code><a title="brickpi3.BrickPi3.transact_i2c" href="#brickpi3.BrickPi3.transact_i2c">transact_i2c</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="brickpi3.Enumeration" href="#brickpi3.Enumeration">Enumeration</a></code></h4>
</li>
<li>
<h4><code><a title="brickpi3.FirmwareVersionError" href="#brickpi3.FirmwareVersionError">FirmwareVersionError</a></code></h4>
</li>
<li>
<h4><code><a title="brickpi3.SensorError" href="#brickpi3.SensorError">SensorError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>